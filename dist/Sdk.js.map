{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Sdk.js","webpack:///webpack/bootstrap a38d0b43d364a03f949b","webpack:///./~/ts-promise/dist/lib/util.js","webpack:///(webpack)/buildin/global.js","webpack:///./~/ts-promise/dist/lib/BaseError.js","webpack:///./~/ts-promise/dist/lib/Promise.js","webpack:///./src/index.ts","webpack:///./~/global/window.js","webpack:///./~/process/browser.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/timers-browserify/main.js","webpack:///./src/lib/base.ts","webpack:///./src/lib/browser.ts","webpack:///./src/lib/effects.ts","webpack:///./src/lib/event.ts","webpack:///./src/lib/http.ts","webpack:///./src/lib/storage.ts","webpack:///./src/lib/utils.ts","webpack:///./src/polyfill/object-assign.ts","webpack:///./~/ts-promise/dist/lib/Stack.js","webpack:///./~/ts-promise/dist/lib/Trace.js","webpack:///./~/ts-promise/dist/lib/async.js","webpack:///./~/ts-promise/dist/lib/index.js","webpack:///./~/ts-promise/dist/lib/polyfill.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","assert","condition","msg","Error","getGlobal","self","window","g","Function","e","eval","__extends","b","__","constructor","create","hasStacks","captureStackTrace","BaseError","_super","message","stack","default","internalResolver","fulfill","reject","noop","wrapNonError","a","async_1","util_1","Trace_1","BaseError_1","UnhandledRejectionError","reason","trace","String","State","undefined","longTraces","getThenError","error","dummyDoneTrace","unwrappingPromise","promiseIdCounter","Promise","resolver","_this","_id","_state","_result","_handlers","_trace","_setSource","TypeError","called","y","_resolve","r","_reject","then","onFulfilled","onRejected","slave","getPrototypeOf","_enqueue","done","doneTrace","setSource","catch","args","_i","arguments","length","predicate_1","onRejected_1","match","Array","isArray","finally","handler","runner","return","isFulfilled","isRejected","isPending","inspect","toString","state","delay","ms","resolve","setTimeout","throw","all","thenables","result","remaining","t","index","v","race","defer","promise","res","rej","ms_1","setLongTraces","enable","setTracer","tracer","flush","source","x","_fulfill","_followPromise","_tryGetThen","_followThenable","_flush","originalStack","h","enqueue","_unwrapper","_unwrap","callback","unhandled","SDK","win","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","process","nextTick","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","setImmediate","task","tasksByHandle","nextHandle","registerImmediate","clearImmediate","handle","runIfPresent","currentlyRunningATask","doc","document","attachTo","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","messagePrefix","Math","random","onGlobalMessage","event","data","indexOf","slice","addEventListener","attachEvent","MessageChannel","channel","port1","port2","createElement","html","documentElement","script","onreadystatechange","removeChild","appendChild","Timeout","id","clearFn","_clearFn","setInterval","clearInterval","close","unref","ref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","http_1","http","browser_1","effects_1","effects","event_1","listen","storage_1","storage","utils","ua","navigator","userAgent","toLowerCase","M","tem","os","test","exec","appName","appVersion","splice","fadeIn","element","speed","style","opacity","display","fadeOut","timer","filter","eventName","capture","split","forEach","makeRequest","opts","ts_promise_1","xhr","XMLHttpRequest","open","method","url","onload","status","JSON","parse","response","statusText","onerror","headers","keys","key","setRequestHeader","params","splitUrl","send","obj","map","k","encodeURIComponent","join","Accept","Content-type","HttpObj","request","uri","doneCallback","errorCallback","options","fetch","mode","credentials","body","HttpF","checkStatus","parseJson","err","post","json","ok","set","console","warn","stringify","localStorage","setItem","getItem","del","removeItem","append","target","_a","assign","SomeUtils","foo","init","log","mainFunction","someFunction","otherUtils","Foo","bar","Bar","args_1","Stack","ignoreUntil","lines","shift","Stack_1","Trace","sources","traceLimit","CallQueue","_max","_first","arg","Async","_pool","_ring","_current","_flusher","_scheduledFlush","_flushing","_scheduled","_scheduler","setScheduler","scheduler","_schedule","pop","async","Promise_1","polyfill_1","polyfill","force"],"mappings":"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","file":"Sdk.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Sdk\"] = factory();\n\telse\n\t\troot[\"Sdk\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Sdk\"] = factory();\n\telse\n\t\troot[\"Sdk\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 22);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * Helper utilities.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\n/**\n * Throw an Error when given condition is false.\n *\n * @param {any}    condition Condition, no-op when truthy, error thrown when falsy\n * @param {string} msg       Optional text to include in error message\n */\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg ? \"assertion failed: \" + msg : \"assertion failed\");\n    }\n}\nexports.assert = assert;\n/**\n * Return reference to the global object (if possible).\n *\n * @return {any} Reference to the global object (e.g. `window`, `global`, etc.),\n *               or `undefined` if it could not be determined.\n */\nfunction getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    // Otherwise, try to use `this`.\n    // We use eval-like behavior, because it will not inherit our \"use strict\",\n    // see http://stackoverflow.com/questions/3277182/how-to-get-the-global-object-in-javascript\n    var g;\n    try {\n        g = new Function(\"return this\")();\n    }\n    catch (e) {\n    }\n    return g;\n}\nexports.getGlobal = getGlobal;\n//# sourceMappingURL=util.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Base class for custom errors.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar hasStacks = (typeof Error.captureStackTrace === \"function\");\nvar BaseError = (function (_super) {\n    __extends(BaseError, _super);\n    function BaseError(name, message) {\n        _super.call(this, message);\n        this.name = name;\n        // Note: still need to 'manually' assign .message,\n        // because engines apparently don't allow subclassing properly.\n        // https://github.com/Microsoft/TypeScript/issues/1168#issuecomment-107729088\n        this.message = message;\n        /* istanbul ignore else */ // TODO: remove when testing for non-V8\n        if (hasStacks) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        else {\n            this.stack = \"dummy\\n<no trace>\";\n        }\n    }\n    return BaseError;\n}(Error));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BaseError;\n//# sourceMappingURL=BaseError.js.map\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Promise implementation in TypeScript.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/* tslint:disable:no-unused-expression */ // prevent errors on `trace && trace(....)`\n// TODO:\n// - remove all \"called = true\"-type code in resolvers, replace by single check in _resolve()/_reject()\n// - add possibility for an unhandled-rejections-handler\n// - try to remove mangling of Error's .stack property on rejections with longTraces enabled\nvar async_1 = __webpack_require__(19);\nvar util_1 = __webpack_require__(0);\nvar Trace_1 = __webpack_require__(18);\nvar BaseError_1 = __webpack_require__(2);\n/**\n * Thrown when a rejected promise is explicitly terminated with `.done()`.\n */\nvar UnhandledRejectionError = (function (_super) {\n    __extends(UnhandledRejectionError, _super);\n    function UnhandledRejectionError(reason, trace) {\n        _super.call(this, \"UnhandledRejectionError\", \"unhandled rejection: \" + reason);\n        this.reason = reason;\n        // TODO: Find a better way to merge the location of `.done()` in the\n        // trace, because nobody will look for this property...\n        this.trace = trace;\n        // In case we have a reason, and it has a stack: use it instead of our\n        // own stack, as it's more helpful to see where the original error was\n        // thrown, than where it was thrown inside the promise lib.\n        // In case we don't have a stack, explicitly state so, to not let people\n        // chase a problem in the promise lib that isn't there...\n        var stack = this.reason && typeof this.reason === \"object\" && this.reason.stack;\n        if (typeof stack !== \"string\") {\n            stack = String(reason);\n        }\n        this.stack = \"UnhandledRejectionError: \" + stack;\n    }\n    return UnhandledRejectionError;\n}(BaseError_1.default));\nexports.UnhandledRejectionError = UnhandledRejectionError;\nvar trace = undefined;\nvar longTraces = false;\nvar State;\n(function (State) {\n    State[State[\"Pending\"] = 0] = \"Pending\";\n    State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n    State[State[\"Rejected\"] = 2] = \"Rejected\";\n})(State || (State = {}));\nfunction internalResolver(fulfill, reject) {\n    /* no-op, sentinel value */\n}\ninternalResolver(undefined, undefined); // just for code coverage...\nfunction noop() {\n    /* no-op */\n}\nvar getThenError = {\n    error: undefined,\n};\nfunction wrapNonError(a) {\n    // This is basically a marker for the places where we need to check\n    // handling of errors for .error() support.\n    // A no-op for now.\n    return a;\n}\nvar dummyDoneTrace = new Trace_1.default();\n/**\n * Currently unwrapping promise, while running one of its then-callbacks.\n * Used to set the source of newly created promises.\n * We guarantee that at most one callback of a then() is running at any time.\n */\nvar unwrappingPromise = undefined;\nvar promiseIdCounter = 0;\n/**\n * Fast, robust, type-safe promise implementation.\n */\nvar Promise = (function () {\n    /**\n     * Create new Promise.\n     *\n     * Pass a callback that will receive a `resolve()` and `reject()` function\n     * to seal the promise's fate.\n     *\n     * @param  resolver Called with resolve and reject functions\n     */\n    function Promise(resolver) {\n        var _this = this;\n        this._id = promiseIdCounter++;\n        this._state = 0 /* Pending */;\n        this._result = undefined; // Can be fulfillment value or rejection reason\n        this._handlers = undefined;\n        this._trace = undefined;\n        trace && trace(this, \"construct\");\n        if (longTraces) {\n            this._trace = new Trace_1.default(Promise);\n            if (unwrappingPromise) {\n                this._setSource(unwrappingPromise);\n            }\n        }\n        if (resolver === internalResolver) {\n            // Internally created promises pass 'internalResolver', signalling\n            // that resolving will be done by calling private methods on the\n            // Promise. This saves having to create 2 closures.\n            return;\n        }\n        if (typeof resolver !== \"function\") {\n            throw new TypeError(\"Promise resolver is not a function\");\n        }\n        var called = false;\n        try {\n            resolver(function (y) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,\n                // run `[[Resolve]](promise, y)`\n                called = true;\n                _this._resolve(y);\n            }, function (r) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,\n                // reject `promise` with `r`\n                called = true;\n                _this._reject(wrapNonError(r));\n            });\n        }\n        catch (e) {\n            // 2.3.3.3.4: If calling `then` throws an exception `e`,\n            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.\n            if (!called) {\n                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.\n                called = true;\n                this._reject(wrapNonError(e));\n            }\n        }\n    }\n    /**\n     * Run either `onFulfilled` or `onRejected` callbacks when the promise is\n     * resolved. Returns another promise for the return value of such a\n     * callback.\n     *\n     * The callback will always be called at most once, and always\n     * asynchronously (i.e. some time after e.g. the `resolver` passed to the\n     * constructor has resolved the promise).\n     *\n     * Any error thrown or rejected promise returned from a callback will cause\n     * the returned promise to be rejected with that error.\n     *\n     * If either or both callbacks are missing, the fulfillment or rejection is\n     * passed on unmodified.\n     *\n     * Use `.catch(onRejected)` instead of `.then(undefined, onRejected)` for\n     * stronger typing, better readability, and more functionality (predicates).\n     *\n     * @param onFulfilled Callback called with promise's fulfillment\n     *                    value iff promise is fulfilled. Callback can return\n     *                    another value or promise for a value.\n     * @param onRejected  Optional callback called with promise's rejection\n     *                    reason iff promise is rejected. Callback can return\n     *                    another value or promise for a value.\n     * @return Promise for value returned by either of the callbacks\n     */\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        trace && trace(this, \"then(\" + typeof onFulfilled + \", \" + typeof onRejected + \")\");\n        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== \"function\" ||\n            this._state === 2 /* Rejected */ && typeof onRejected !== \"function\") {\n            // Optimization: handler is short-circuited, so pass the result (value/rejection)\n            // through unmodified.\n            // The typecast is safe, because we either have a fulfillment value\n            // but no handler that could change the type, or a rejection without a\n            // handler that could change it, so R === T in this case.\n            // TODO: verify whether longTraces etc still work as expected\n            return this;\n        }\n        // Construct new Promise, but use subclassed constructor, if any\n        var slave = new (Object.getPrototypeOf(this).constructor)(internalResolver);\n        slave._setSource(this);\n        this._enqueue(onFulfilled, onRejected, slave, undefined);\n        return slave;\n    };\n    /**\n     * Run either `onFulfilled` or `onRejected` callbacks when the promise is\n     * resolved. If the callback throws an error or the returned value resolves\n     * to a rejection, the library will (asynchronously) throw an\n     * `UnhandledRejectionError` with that error.\n     *\n     * The callback will always be called at most once, and always\n     * asynchronously (i.e. some time after e.g. the `resolver` passed to the\n     * constructor has resolved the promise).\n     *\n     * @param onFulfilled Optional callback called with promise's fulfillment\n     *                    value iff promise is fulfilled. Any error thrown or\n     *                    rejection returned will cause an UnhandledRejectionError\n     *                    to be thrown.\n     * @param onRejected  Optional callback called with promise's rejection\n     *                    reason iff promise is rejected. Any error thrown or\n     *                    rejection returned will cause an UnhandledRejectionError\n     *                    to be thrown.\n     */\n    Promise.prototype.done = function (onFulfilled, onRejected) {\n        trace && trace(this, \"done(\" + typeof onFulfilled + \", \" + typeof onRejected + \")\");\n        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== \"function\") {\n            return;\n        }\n        var doneTrace = dummyDoneTrace;\n        if (longTraces) {\n            doneTrace = new Trace_1.default();\n            if (this._trace) {\n                doneTrace.setSource(this._trace);\n            }\n        }\n        this._enqueue(onFulfilled, onRejected, undefined, doneTrace);\n    };\n    /**\n     * Catch only errors that match predicate in case promise is rejected.\n     * Predicate can be an Error (sub-)class, array of Error classes, or a\n     * function that can return true to indicate a match.\n     *\n     * The returned promise is resolved with the output of the callback, so it\n     * is possible to re-throw the error, but also to return a 'replacement'\n     * value that should be used instead.\n     *\n     * @param predicate   Optional Error class, array of Error classes or match\n     *                    function\n     * @param onRejected  Callback called with promise's rejection reason iff\n     *                    promise is rejected. Callback can return another value\n     *                    or promise for a value.\n     * @return Promise for original value, or 'replaced' value in case of error\n     */\n    Promise.prototype.catch = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        if (arguments.length === 1) {\n            var onRejected = arguments[0];\n            return this.then(undefined, onRejected);\n        }\n        else {\n            var predicate_1 = arguments[0];\n            var onRejected_1 = arguments[1];\n            return this.then(undefined, function (reason) {\n                var match = false;\n                if (typeof predicate_1 === \"function\") {\n                    if (predicate_1.prototype instanceof Error || predicate_1 === Error) {\n                        match = reason instanceof predicate_1;\n                    }\n                    else {\n                        match = predicate_1(reason);\n                    }\n                }\n                else if (Array.isArray(predicate_1)) {\n                    for (var i = 0; i < predicate_1.length; i++) {\n                        if (reason instanceof predicate_1[i]) {\n                            match = true;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    throw new TypeError(\"invalid predicate to .catch(), got \" + typeof predicate_1);\n                }\n                if (match) {\n                    return onRejected_1(reason);\n                }\n                return Promise.reject(reason);\n            });\n        }\n    };\n    /**\n     * Asynchronous equivalent of try { } finally { }.\n     *\n     * Runs `handler` when promise resolves (fulfilled or rejected).\n     * Handler is passed the current promise (which is guaranteed to be\n     * resolved), and can be interrogated with e.g. `isFulfilled()`, `.value()`,\n     * etc.\n     *\n     * When `handler` returns `undefined` or its promise is fulfilled, the\n     * promise from `finally()` is resolved to the original promise's resolved\n     * value or rejection reason.\n     * If `handler` throws an error or returns a rejection, the result of\n     * `finally()` will be rejected with that error.\n     *\n     * Example:\n     * someLenghtyOperation().finally((result) => {\n     *   if (result.isFulfilled()) {\n     *     console.log(\"succeeded\");\n     *   } else {\n     *     console.log(\"failed\", result.reason());\n     *   }\n     * });\n     *\n     * @param  handler [description]\n     * @return promise with same value/reason as this one, after `handler`'s\n     *         result (if any) has been fulfilled, or a promise rejected with\n     *         `handler`'s error if it threw one or returned a rejection.\n     */\n    Promise.prototype.finally = function (handler) {\n        var _this = this;\n        var runner = function () { return handler(_this); };\n        return this.then(runner, runner).return(this);\n    };\n    /**\n     * @return `true` when promise is fulfilled, `false` otherwise.\n     */\n    Promise.prototype.isFulfilled = function () {\n        return this._state === 1 /* Fulfilled */;\n    };\n    /**\n     * @return `true` when promise is rejected, `false` otherwise.\n     */\n    Promise.prototype.isRejected = function () {\n        return this._state === 2 /* Rejected */;\n    };\n    /**\n     * @return `true` when promise is pending (may be resolved to another pending\n     *         promise), `false` otherwise.\n     */\n    Promise.prototype.isPending = function () {\n        return this._state === 0 /* Pending */;\n    };\n    /**\n     * @return Fulfillment value if fulfilled, otherwise throws an error.\n     */\n    Promise.prototype.value = function () {\n        if (!this.isFulfilled()) {\n            throw new Error(\"Promise is not fulfilled\");\n        }\n        return this._result;\n    };\n    /**\n     * @return Rejection reason if rejected, otherwise throws an error.\n     */\n    Promise.prototype.reason = function () {\n        if (!this.isRejected()) {\n            throw new Error(\"Promise is not rejected\");\n        }\n        return this._result;\n    };\n    /**\n     * @return A human-readable representation of the promise and its status.\n     */\n    Promise.prototype.inspect = function () {\n        return this.toString();\n    };\n    /**\n     * @return A human-readable representation of the promise and its status.\n     */\n    Promise.prototype.toString = function () {\n        var state;\n        switch (this._state) {\n            case 0 /* Pending */:\n                state = \"pending\";\n                break;\n            case 1 /* Fulfilled */:\n                state = \"fulfilled\";\n                break;\n            case 2 /* Rejected */:\n                state = \"rejected\";\n                break;\n            /* istanbul ignore next */\n            default: state = \"unknown\";\n        }\n        return \"[Promise \" + this._id + \": \" + state + \"]\";\n    };\n    /**\n     * Create a promise that resolves with the same value of this promise, after\n     * `ms` milliseconds. The timer will start when the current promise is\n     * resolved.\n     * If the current promise is rejected, the resulting promise is also\n     * rejected, without waiting for the timer.\n     *\n     * @param ms Number of milliseconds to wait before resolving\n     * @return Promise that fulfills `ms` milliseconds after this promise fulfills\n     */\n    Promise.prototype.delay = function (ms) {\n        return this.then(function (value) {\n            return new Promise(function (resolve) {\n                setTimeout(function () { return resolve(value); }, ms);\n            });\n        });\n    };\n    /**\n     * Return a promise that resolves to `value` after this promise is\n     * fulfilled.\n     * Returned promise is rejected if this promise is rejected.\n     *\n     * Equivalent to `.then(() => value)`.\n     *\n     * @param value Value or promise for value of returned promise\n     * @return Promise resolved to value after this promise fulfills\n     */\n    Promise.prototype.return = function (value) {\n        if (value === undefined) {\n            // In TypeScript, we often need to 'force' a promise to become a\n            // void promise, so this is a common case. Prevents the closure.\n            // (Note: the any cast is just because TS assumes were going to\n            // return an R, but we're in fact going to return a void.)\n            return this.then(noop);\n        }\n        return this.then(function () { return value; });\n    };\n    /**\n     * Return a promise that is rejected with `reason` after this promise is\n     * fulfilled.\n     * If this promise is rejected, returned promise will rejected with that\n     * error instead.\n     *\n     * Equivalent to `.then(() => { throw value; })`.\n     *\n     * @param reason Error reason to reject returned promise with\n     * @return Promise rejected with `reason` after this promise fulfills\n     */\n    Promise.prototype.throw = function (reason) {\n        return this.then(function () { return Promise.reject(reason); });\n    };\n    /**\n     * Create an immediately resolved promise (in case of a 'normal' value), or\n     * a promise that 'follows' another `Thenable` (e.g. a Promise from another\n     * library).\n     *\n     * @param value Value (or Thenable for value) for returned promise\n     * @return Promise resolved to `value`\n     */\n    Promise.resolve = function (value) {\n        var p = new Promise(internalResolver);\n        p._resolve(value);\n        return p;\n    };\n    /**\n     * Create an immediately rejected promise.\n     *\n     * Note: to create a rejected promise of a certain type, use e.g.\n     * `Promise.reject<number>(myError)`\n     *\n     * @param reason Error object to set rejection reason\n     * @return Promise resolved to rejection `reason`\n     */\n    Promise.reject = function (reason) {\n        var p = new Promise(internalResolver);\n        p._reject(reason);\n        return p;\n    };\n    /**\n     * Return a promise for an array of all resolved input promises (or values).\n     * If any of the input promises is rejected, the returned promise is\n     * rejected with that reason.\n     * When passing an empty array, the promises is immediately resolved to an\n     * empty array.\n     *\n     * @param thenables Array of values or promises for them\n     * @return promise that resolves with array of all resolved values\n     */\n    Promise.all = function (thenables) {\n        return new Promise(function (resolve, reject) {\n            util_1.assert(Array.isArray(thenables), \"thenables must be an Array\");\n            if (thenables.length === 0) {\n                resolve([]);\n                return;\n            }\n            var result = new Array(thenables.length);\n            var remaining = thenables.length;\n            for (var i = 0; i < thenables.length; i++) {\n                follow(thenables[i], i);\n            }\n            function follow(t, index) {\n                var slave = t instanceof Promise ? t : Promise.resolve(t);\n                slave.done(function (v) {\n                    result[index] = v;\n                    remaining--;\n                    if (remaining === 0) {\n                        resolve(result);\n                    }\n                }, function (reason) { return reject(reason); });\n            }\n        });\n    };\n    /**\n     * Return a promise that resolves to the fulfillment or rejection of the\n     * first input promise that resolves.\n     * When passing an empty array, the promise will never resolve.\n     *\n     * @param thenables Array of values or promises for them\n     * @return promise that resolves to first resolved input promise\n     */\n    Promise.race = function (thenables) {\n        return new Promise(function (resolve, reject) {\n            util_1.assert(Array.isArray(thenables), \"thenables must be an Array\");\n            for (var i = 0; i < thenables.length; i++) {\n                var t = thenables[i];\n                var slave = t instanceof Promise ? t : Promise.resolve(t);\n                Promise.resolve(slave).done(resolve, reject);\n            }\n        });\n    };\n    /**\n     * Create tuple of a promise and its resolve and reject functions.\n     *\n     * It is generally better (and slightly faster) to use the Promise\n     * constructor to create a promise, as that will also catch any exception\n     * thrown while running the resolver.\n     *\n     * A Deferred can be useful in some scenarios though, e.g. when working with\n     * timers, protocol request/response pairs, etc.\n     *\n     * @return Deferred object, containing unresolved promise and its\n     *         resolve/reject functions\n     */\n    Promise.defer = function () {\n        var resolve;\n        var reject;\n        var p = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        return {\n            promise: p,\n            reject: reject,\n            resolve: resolve,\n        };\n    };\n    /**\n     * Create a promise that resolves to the given value (or promise for a\n     * value) after `ms` milliseconds. The timer will start when the given value\n     * is resolved.\n     * If the input value is a rejected promise, the resulting promise is also\n     * rejected, without waiting for the timer.\n     *\n     * @param value Value or promise for value to be delayed\n     * @param ms Number of milliseconds to wait before resolving\n     * @return Promise that fulfills `ms` milliseconds after given (promise for)\n     *         value is fulfilled\n     */\n    Promise.delay = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        if (arguments[1] === undefined) {\n            // delay(ms)\n            var ms_1 = arguments[0];\n            return new Promise(function (resolve) {\n                setTimeout(resolve, ms_1);\n            });\n        }\n        // delay(value, ms)\n        return Promise.resolve(arguments[0]).delay(arguments[1]);\n    };\n    /**\n     * Enable or disable long stack trace tracking on promises.\n     *\n     * This allows tracing a promise chain through the various asynchronous\n     * actions in a program. For example, when a promise is rejected, the last\n     * few locations of any preceding promises are included in the error's stack\n     * trace.\n     *\n     * Note: it is possible to enable/disable long tracing at runtime.\n     *\n     * When chaining off of a promise that was created while tracing was enabled\n     * (e.g. through `.then()`), all children will also have long traces, even\n     * when tracing is turned off. This allows to trace just some promise paths.\n     *\n     * Tracing is disabled by default as it incurs a memory and performance\n     * overhead, although it's still faster with tracing than some major\n     * promise libraries without tracing, so don't worry too much about it.\n     *\n     * @param enable Set to true to enable long traces, false to disable\n     */\n    Promise.setLongTraces = function (enable) {\n        longTraces = enable;\n    };\n    /**\n     * Set trace function that is called for internal state changes of a\n     * promise.\n     * Call with `undefined` or `null` to disable such tracing (this is the\n     * default).\n     *\n     * @param tracer Callback called for various stages during lifetime of a promise\n     */\n    Promise.setTracer = function (tracer) {\n        if (typeof tracer === \"function\") {\n            trace = tracer;\n        }\n        else {\n            trace = undefined;\n        }\n    };\n    /**\n     * Recursively flush the async callback queue until all `.then()` and\n     * `.done()` callbacks for fulfilled and rejected Promises have been called.\n     * Useful in e.g. unit tests to advance program state to the next 'tick'.\n     *\n     * Note that if e.g. `.done()` encounters a rejected promise, `flush()` will\n     * immediately throw an error (e.g. `UnhandledRejectionError`).\n     * It is safe to call `flush()` again afterwards, but it will also be called\n     * automatically by the async queue on the next 'real' tick.\n     *\n     * It is an error to call `flush()` while it is already running (e.g. from\n     * a `.then()` callback).\n     */\n    Promise.flush = function () {\n        async_1.default.flush();\n    };\n    Promise.prototype._setSource = function (source) {\n        if (!this._trace || !source._trace) {\n            return;\n        }\n        this._trace.setSource(source._trace);\n    };\n    Promise.prototype._resolve = function (x) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        if (!x) {\n            // Shortcut for falsy values, most notably void-Promises\n            // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`\n            this._fulfill(x);\n            return;\n        }\n        // 2.3.1: If promise and x refer to the same object, reject promise with a TypeError as the reason.\n        if (this === x) {\n            this._reject(new TypeError(\"cannot resolve Promise to self\"));\n            return;\n        }\n        // 2.3.2: If `x` is a promise, adopt its state\n        if (x instanceof Promise) {\n            x._setSource(this);\n            if (x._state === 0 /* Pending */) {\n                // 2.3.2.1: If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.\n                this._followPromise(x);\n            }\n            else if (x._state === 1 /* Fulfilled */) {\n                // 2.3.2.2: If/when `x` is fulfilled, fulfill `promise` with the same value.\n                this._fulfill(x._result);\n            }\n            else {\n                // 2.3.2.3: If/when `x` is rejected, reject `promise` with the same reason.\n                this._reject(x._result);\n            }\n            return;\n        }\n        // 2.3.3: Otherwise, if `x` is an object or function,\n        if (typeof x === \"object\" || typeof x === \"function\") {\n            // 2.3.3.1: Let `then` be `x.then`\n            var then = this._tryGetThen(x);\n            // 2.3.3.2: If retrieving the property `x.then` results in a thrown\n            // exception `e`, reject `promise` with `e` as the reason.\n            if (then === getThenError) {\n                this._reject(wrapNonError(getThenError.error));\n                return;\n            }\n            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,\n            //          first argument `resolvePromise`, and second argument `rejectPromise`\n            if (typeof then === \"function\") {\n                this._followThenable(x, then);\n                return;\n            }\n        }\n        // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`\n        this._fulfill(x);\n    };\n    Promise.prototype._tryGetThen = function (x) {\n        try {\n            // 2.3.3.1: Let `then` be `x.then`\n            var then = x.then;\n            return then;\n        }\n        catch (e) {\n            // 2.3.3.2: If retrieving the property `x.then` results in a thrown\n            // exception `e`, reject `promise` with `e` as the reason.\n            getThenError.error = e;\n            return getThenError;\n        }\n    };\n    Promise.prototype._fulfill = function (value) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_fulfill(\" + typeof value + \")\");\n        // 2.1.2.2 When fulfilled, a promise must have a value, which must not change.\n        this._state = 1 /* Fulfilled */;\n        this._result = value;\n        this._flush();\n    };\n    Promise.prototype._reject = function (reason) {\n        var _this = this;\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_reject(\" + reason + \")\");\n        // 2.1.3.2 When rejected, a promise must have a reason, which must not change.\n        this._state = 2 /* Rejected */;\n        this._result = reason;\n        if (this._trace && this._result instanceof Error && !this._result.trace) {\n            this._result.trace = this._trace;\n            // TODO: Meh, this always accesses '.stack', which is supposed to be expensive\n            var originalStack = this._result.stack;\n            // Stack may be undefined if e.g. a Stack Overflow occurred\n            if (originalStack) {\n                Object.defineProperty(this._result, \"stack\", {\n                    enumerable: false,\n                    get: function () { return originalStack + \"\\n  from Promise at:\\n\" + _this._trace.inspect(); },\n                });\n            }\n        }\n        this._flush();\n    };\n    Promise.prototype._followPromise = function (slave) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_follow([Promise \" + slave._id + \"])\");\n        slave._enqueue(undefined, undefined, this, undefined);\n    };\n    Promise.prototype._followThenable = function (slave, then) {\n        var _this = this;\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_follow([Thenable])\");\n        var called = false;\n        try {\n            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,\n            //          first argument `resolvePromise`, and second argument `rejectPromise`\n            then.call(slave, function (y) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,\n                // run `[[Resolve]](promise, y)`\n                called = true;\n                _this._resolve(y);\n            }, function (r) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,\n                // reject `promise` with `r`\n                called = true;\n                _this._reject(wrapNonError(r));\n            });\n        }\n        catch (e) {\n            // 2.3.3.3.4: If calling `then` throws an exception `e`,\n            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.\n            if (!called) {\n                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.\n                called = true;\n                this._reject(wrapNonError(e));\n            }\n        }\n    };\n    Promise.prototype._enqueue = function (onFulfilled, onRejected, slave, done) {\n        var h = {\n            promise: this,\n            onFulfilled: onFulfilled,\n            onRejected: onRejected,\n            slave: slave,\n            done: done,\n        };\n        if (this._state !== 0 /* Pending */) {\n            async_1.default.enqueue(Promise._unwrapper, h);\n        }\n        else {\n            if (!this._handlers) {\n                this._handlers = [h];\n            }\n            else {\n                var i = this._handlers.length;\n                this._handlers[i] = h;\n            }\n        }\n    };\n    /**\n     * Schedule any pending .then()/.done() callbacks and follower-promises to\n     * be called/resolved.\n     * Clears our queue, any callbacks/followers attached after this will be\n     * scheduled without going through our handlers queue.\n     */\n    Promise.prototype._flush = function () {\n        if (!this._handlers) {\n            return;\n        }\n        var i = 0;\n        var h = this._handlers;\n        var l = h.length;\n        this._handlers = undefined;\n        while (i < l) {\n            // Note: we enqueue every single callback/follower separately,\n            // because e.g. .done() might throw and we need to ensure we can\n            // continue after that. async handles that for us.\n            // And because the queue needs to be processed in-order, we can't\n            // 'filter' the non-callback operations out either.\n            async_1.default.enqueue(Promise._unwrapper, h[i++]);\n        }\n    };\n    /**\n     * 'Unwrap' a promise handler, i.e. call a .then()/.done() callback, or\n     * resolve a promise that's following us.\n     * @param handler The handler being processed\n     */\n    Promise.prototype._unwrap = function (handler) {\n        var callback = this._state === 1 /* Fulfilled */ ? handler.onFulfilled : handler.onRejected;\n        if (handler.done) {\n            // Unwrap .done() callbacks\n            trace && trace(this, \"_unwrap()\");\n            if (typeof callback !== \"function\") {\n                // No callback: if we ended in a rejection, throw it, otherwise\n                // all was good.\n                if (this._state === 2 /* Rejected */) {\n                    var unhandled = new UnhandledRejectionError(this._result, handler.done);\n                    // TODO Allow intercepting these\n                    // Leave the comment after the throw: may show up in source line in node\n                    throw unhandled; // Unhandled exception caught by .done()\n                }\n                return;\n            }\n            util_1.assert(!unwrappingPromise);\n            unwrappingPromise = this;\n            try {\n                var result = callback(this._result);\n                if (result) {\n                    // May be a thenable, need to start following it...\n                    var p = (result instanceof Promise) ? result : Promise.resolve(result);\n                    p.done(); // Ensure it throws as soon as it's rejected\n                }\n                unwrappingPromise = undefined;\n            }\n            catch (e) {\n                unwrappingPromise = undefined;\n                // Wrap in UnhandledRejectionError\n                var unhandled = new UnhandledRejectionError(e, handler.done);\n                // TODO Allow intercepting these\n                // Leave the comment after the throw: may show up in source line in node\n                throw unhandled; // Unhandled exception caught by .done()\n            }\n            return;\n        }\n        // Unwrap .then() callbacks, or resolve 'parent' promise\n        //\n        // Three scenarios are handled here:\n        // 1. An onFulfilled callback was registered and promise is fulfilled,\n        //    or onRejected callback was registered and promise is rejected\n        //    -> callback is a function, slave is the promise that was returned\n        //       from the .then() call, so resolve slave with outcome of callback\n        // 2. An onFulfilled callback was registered but promise is rejected,\n        //    or onRejected callback was registered but promise is fulfilled\n        //    -> callback is not a function (typically `undefined`), slave is\n        //       promise that was returned from the .then() call, so resolve it\n        //       with our own result (thereby 'skipping' the .then())\n        // 3. Another promise attached itself on our 'callback queue' to be\n        //    resolved when we do (i.e. its fate is determined by us)\n        //    -> callbacks will both be undefined, slave is that other promise\n        //       that wants to be resolved with our result\n        var slave = handler.slave;\n        trace && trace(this, \"_unwrap(\" + slave._id + \")\");\n        if (typeof callback === \"function\") {\n            // Case 1\n            util_1.assert(!unwrappingPromise);\n            unwrappingPromise = slave;\n            try {\n                // 2.2.5 handlers must be called as functions\n                slave._resolve(callback(this._result));\n            }\n            catch (e) {\n                slave._reject(wrapNonError(e));\n            }\n            unwrappingPromise = undefined;\n        }\n        else {\n            // Case 2 and 3\n            if (this._state === 1 /* Fulfilled */) {\n                slave._fulfill(this._result);\n            }\n            else {\n                slave._reject(this._result);\n            }\n        }\n    };\n    /**\n     * Helper for unwrapping promise handler.\n     * It's not a closure so it's cheap to schedule, and because it directly\n     * calls the _unwrap() method on a promise, it's (way) faster than having to\n     * use e.g. .call().\n     * @param handler The handler being processed\n     */\n    Promise._unwrapper = function (handler) {\n        handler.promise._unwrap(handler);\n    };\n    return Promise;\n}());\nexports.Promise = Promise;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Promise;\n//# sourceMappingURL=Promise.js.map\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar SDK = __webpack_require__(9);\r\nmodule.exports = SDK;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(6)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(7);\nvar global = __webpack_require__(5);\nexports.setImmediate = global.setImmediate;\nexports.clearImmediate = global.clearImmediate;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar http_1 = __webpack_require__(13);\r\nexports.http = http_1.default;\r\nvar browser_1 = __webpack_require__(10);\r\nexports.browser = browser_1.default;\r\nvar effects_1 = __webpack_require__(11);\r\nexports.effects = effects_1.default;\r\nvar event_1 = __webpack_require__(12);\r\nexports.listen = event_1.default;\r\nvar storage_1 = __webpack_require__(14);\r\nexports.storage = storage_1.default;\r\nvar utils = __webpack_require__(15);\r\nexports.utils = utils;\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar getBrowserInfo = function () {\r\n    var ua = navigator.userAgent.toLowerCase();\r\n    var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || [];\r\n    var tem = M;\r\n    var os = 'Windows';\r\n    switch (true) {\r\n        case ua.indexOf('Win') > -1:\r\n            os = 'Windows';\r\n            break;\r\n        case ua.indexOf('Mac') > -1:\r\n            os = 'MacOS';\r\n            break;\r\n        case ua.indexOf('X11') > -1:\r\n            os = 'UNIX';\r\n            break;\r\n        case ua.indexOf('Linux') > -1:\r\n            os = 'Linux';\r\n            break;\r\n    }\r\n    if (/trident/i.test(M[1])) {\r\n        tem = /\\brv[ :]+(\\d+)/g.exec(ua) || [];\r\n        return {\r\n            name: 'IE ',\r\n            version: (tem[1] || ''),\r\n            os: os\r\n        };\r\n    }\r\n    if (M[1] === 'chrome') {\r\n        tem = ua.match(/\\bOPR\\/(\\d+)/);\r\n        if (tem !== null) {\r\n            return {\r\n                name: 'Opera',\r\n                version: tem[1],\r\n                os: os\r\n            };\r\n        }\r\n    }\r\n    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];\r\n    if ((tem = ua.match(/version\\/(\\d+)/i)) !== null) {\r\n        M.splice(1, 1, tem[1]);\r\n    }\r\n    return {\r\n        name: M[0],\r\n        version: M[1],\r\n        os: os\r\n    };\r\n};\r\nvar browser = getBrowserInfo();\r\nvar name = browser.name.toLowerCase();\r\nvar version = browser.version;\r\nvar os = browser.os;\r\nexports.default = {\r\n    name: name,\r\n    version: version,\r\n    os: os\r\n};\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar effects = {};\r\neffects.fadeIn = function (element, speed) {\r\n    if (speed === void 0) { speed = 0; }\r\n    // console.trace();\r\n    speed = speed + 0.1;\r\n    element.style.opacity = speed;\r\n    element.style.display = 'block';\r\n    if (speed < 1) {\r\n        setTimeout(function () {\r\n            effects.fadeIn(element, speed);\r\n        }, 10);\r\n    }\r\n};\r\neffects.fadeOut = function (element, speed) {\r\n    if (speed === void 0) { speed = 1; }\r\n    // console.trace();\r\n    var timer = setInterval(function () {\r\n        if (speed <= 0.0) {\r\n            clearInterval(timer);\r\n        }\r\n        element.style.opacity = speed;\r\n        element.style.display = 'none';\r\n        element.style.filter = 'alpha(opacity=' + speed * 100 + \")\";\r\n        speed -= 0.1;\r\n    }, 25);\r\n};\r\nexports.default = effects;\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar listen = function (args) {\r\n    if (args === void 0) { args = {}; }\r\n    var element = args.element || {};\r\n    var eventName = args.eventName || {};\r\n    var callback = args.callback || {};\r\n    var capture = args.capture || false;\r\n    eventName.split(' ').forEach(function (e) { return element.addEventListener((e), (callback), (capture)); });\r\n};\r\nexports.default = listen;\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ts_promise_1 = __webpack_require__(20);\r\nvar HttpObj = {\r\n    request: function (args) {\r\n        if (args === void 0) { args = {}; }\r\n        // {method, url, data, doneCallback, errorCallback, timeout = 30}\r\n        var params = '';\r\n        var uri = args.url || '';\r\n        var data = args.data || '';\r\n        var method = args.method || 'get';\r\n        var doneCallback = args.doneCallback || (function () { });\r\n        var errorCallback = args.errorCallback || (function () { });\r\n        var timeout = args.timeout || '30';\r\n        var options = {};\r\n        method = method.toLowerCase();\r\n        if (window.fetch) {\r\n            // 支持fetch\r\n            switch (method) {\r\n                case 'post':\r\n                    // TODO:\r\n                    options = {\r\n                        mode: 'no-cors',\r\n                        method: 'post',\r\n                        credentials: 'include',\r\n                        headers: headers(),\r\n                        body: splitUrl(data)\r\n                    };\r\n                    break;\r\n                default:\r\n                    params = typeof data === 'object' ? '?' + splitUrl(data) : '';\r\n                    uri = uri + params;\r\n                    options = {\r\n                        mode: 'no-cors',\r\n                        credentials: 'include',\r\n                    };\r\n                    break;\r\n            }\r\n            // 发起fetch请求\r\n            fetch(uri, options)\r\n                .then(HttpF.checkStatus)\r\n                .then(HttpF.parseJson)\r\n                .then(doneCallback)\r\n                .catch(errorCallback);\r\n        }\r\n        else {\r\n            // 不支持fetch\r\n            switch (method) {\r\n                case 'post':\r\n                    makeRequest({\r\n                        method: method,\r\n                        url: uri,\r\n                        params: data,\r\n                        headers: headers()\r\n                    })\r\n                        .then(doneCallback)\r\n                        .catch(errorCallback);\r\n                    break;\r\n                default:\r\n                    params = typeof data === 'object' ? '?' + splitUrl(data) : '';\r\n                    uri = uri + params;\r\n                    makeRequest({\r\n                        method: method,\r\n                        url: uri,\r\n                        params: data,\r\n                        headers: headers()\r\n                    })\r\n                        .then(doneCallback)\r\n                        .catch(errorCallback);\r\n                    break;\r\n            }\r\n        }\r\n    },\r\n    get: function (uri, doneCallback) {\r\n        if (uri === void 0) { uri = ''; }\r\n        if (typeof uri !== 'string') {\r\n            return 'uri invalid';\r\n        }\r\n        if (window.fetch) {\r\n            // 支持fetch\r\n            var options = {\r\n                mode: 'no-cors',\r\n                credentials: 'include',\r\n            };\r\n            // 发起fetch请求\r\n            fetch(uri, options)\r\n                .then(HttpF.checkStatus)\r\n                .then(HttpF.parseJson)\r\n                .then(doneCallback)\r\n                .catch(function (err) {\r\n                return err;\r\n            });\r\n        }\r\n        else {\r\n            // 不支持fetch\r\n            makeRequest({\r\n                method: 'get',\r\n                url: uri,\r\n                params: '',\r\n                headers: headers()\r\n            })\r\n                .then(doneCallback)\r\n                .catch(function (err) {\r\n                return err;\r\n            });\r\n        }\r\n    },\r\n    post: function (args) {\r\n        if (args === void 0) { args = {}; }\r\n        var params = '';\r\n        var uri = args.url || '';\r\n        var data = args.data || '';\r\n        var method = args.method || 'get';\r\n        var doneCallback = args.doneCallback || (function () { });\r\n        var errorCallback = args.errorCallback || (function () { });\r\n        var timeout = args.timeout || '30';\r\n        var options = {};\r\n        method = method.toLowerCase();\r\n        if (window.fetch) {\r\n            // 支持fetch\r\n            options = {\r\n                mode: 'no-cors',\r\n                method: 'post',\r\n                credentials: 'include',\r\n                headers: headers(),\r\n                body: splitUrl(data)\r\n            };\r\n            // 发起fetch请求\r\n            fetch(uri, options)\r\n                .then(HttpF.checkStatus)\r\n                .then(HttpF.parseJson)\r\n                .then(doneCallback)\r\n                .catch(errorCallback);\r\n        }\r\n        else {\r\n            // 不支持fetch\r\n            makeRequest({\r\n                method: method,\r\n                url: uri,\r\n                params: data,\r\n                headers: headers()\r\n            })\r\n                .then(doneCallback)\r\n                .catch(errorCallback);\r\n        }\r\n    }\r\n};\r\n/**\r\n * 处理请求参数\r\n *\r\n * @type {Object}\r\n */\r\nvar HttpF = {\r\n    parseJson: function (response) {\r\n        return response.json();\r\n    },\r\n    checkStatus: function (response) {\r\n        if (response.ok) {\r\n            return response;\r\n        }\r\n        else {\r\n            var error = new Error(response.statusText);\r\n            error.response = response;\r\n            throw error;\r\n        }\r\n    }\r\n};\r\n/**\r\n * XMLHttpRequest请求，使用Promise特性\r\n */\r\nfunction makeRequest(opts) {\r\n    return new ts_promise_1.default(function (resolve, reject) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(opts.method, opts.url);\r\n        xhr.onload = function (res) {\r\n            if (res.status >= 200 && res.status < 300) {\r\n                resolve(JSON.parse(xhr.response));\r\n            }\r\n            else {\r\n                reject({\r\n                    status: res.status,\r\n                    statusText: xhr.statusText\r\n                });\r\n            }\r\n        };\r\n        xhr.onerror = function (res) {\r\n            reject({\r\n                status: res.status,\r\n                statusText: xhr.statusText\r\n            });\r\n        };\r\n        if (opts.headers) {\r\n            Object.keys(opts.headers).forEach(function (key) {\r\n                xhr.setRequestHeader(key, opts.headers[key]);\r\n            });\r\n        }\r\n        var params = opts.params;\r\n        // 转换对象为字符串\r\n        if (params && typeof params === 'object') {\r\n            params = splitUrl(params);\r\n        }\r\n        xhr.send(params);\r\n    });\r\n}\r\n// 拼接URI\r\nfunction splitUrl(obj) {\r\n    return Object.keys(obj).map(function (k) { return encodeURIComponent(k) + \"=\" + encodeURIComponent(obj[k]); }).join('&');\r\n}\r\nfunction headers() {\r\n    return {\r\n        'Accept': 'application/json, text/plain, */*',\r\n        'Content-type': 'application/x-www-form-urlencoded; charset=UTF-8'\r\n    };\r\n}\r\nvar http = {\r\n    get: HttpObj.get,\r\n    post: HttpObj.post,\r\n    request: HttpObj.request\r\n};\r\nexports.default = http;\r\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(16);\r\nvar storage = {\r\n    set: function (obj) {\r\n        if (obj === void 0) { obj = {}; }\r\n        /* 格式: {key1: value1, key2: {k: v}} */\r\n        if (!obj) {\r\n            console.warn('object invalid');\r\n            return;\r\n        }\r\n        for (var key in obj) {\r\n            var value = obj[key];\r\n            if (!key) {\r\n                console.warn('key invalid');\r\n                return;\r\n            }\r\n            if (typeof value === 'object') {\r\n                value = JSON.stringify(value);\r\n            }\r\n            if (obj.hasOwnProperty(key) && typeof value !== 'function') {\r\n                localStorage.setItem(key, value);\r\n            }\r\n        }\r\n    },\r\n    get: function (key) {\r\n        try {\r\n            var result = localStorage.getItem(key);\r\n            if (result && result[0] === \"{\") {\r\n                result = JSON.parse(result);\r\n            }\r\n            return result;\r\n        }\r\n        catch (e) {\r\n            console.warn('not found value');\r\n            console.error(e);\r\n        }\r\n    },\r\n    del: function (key) {\r\n        try {\r\n            localStorage.removeItem(key);\r\n        }\r\n        catch (e) {\r\n            console.warn('can not remove item');\r\n            console.error(e);\r\n        }\r\n    },\r\n    append: function (key, target) {\r\n        var source = storage.get(key);\r\n        if (source === null) {\r\n            source = {};\r\n        }\r\n        return storage.set((_a = {}, _a[key] = Object.assign(target, source), _a));\r\n        var _a;\r\n    }\r\n};\r\nexports.default = storage;\r\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar SomeUtils = (function () {\r\n    function SomeUtils(options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.foo = options;\r\n        this.params = options.params || {};\r\n    }\r\n    SomeUtils.prototype.init = function (options) {\r\n        console.log(this.foo);\r\n        return options;\r\n    };\r\n    SomeUtils.prototype.mainFunction = function (params) {\r\n        if (params === void 0) { params = {}; }\r\n        // console.log(params)\r\n        console.log('mainFunction');\r\n        return params;\r\n    };\r\n    SomeUtils.prototype.someFunction = function () {\r\n        console.log('someFunction');\r\n    };\r\n    return SomeUtils;\r\n}());\r\n// 内部API\r\nvar otherUtils = (function () {\r\n    function otherUtils(params) {\r\n        this.foo = params.foo || otherUtils.Foo;\r\n        this.bar = params.bar || otherUtils.Bar;\r\n        console.log('Print otherUtils class constructor function: ');\r\n        console.log(params);\r\n    }\r\n    otherUtils.prototype.init = function (options) {\r\n        console.log('Print otherUtils class init function: ');\r\n        console.log(\"foo object: \" + this.foo);\r\n        console.log(\"bar object: \" + this.bar);\r\n        return options;\r\n    };\r\n    otherUtils.Foo = {};\r\n    otherUtils.Bar = 0;\r\n    return otherUtils;\r\n}());\r\nvar o = new otherUtils({ foo: 'foo value', bar: 1 });\r\no.init();\r\nvar utils = SomeUtils;\r\nmodule.exports = utils;\r\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nif (typeof Object.assign !== 'function') {\r\n    (function () {\r\n        Object.assign = function (target) {\r\n            var args = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                args[_i - 1] = arguments[_i];\r\n            }\r\n            if (!target) {\r\n                throw TypeError('Cannot convert undefined or null to object');\r\n            }\r\n            var _loop_1 = function (source) {\r\n                if (source) {\r\n                    Object.keys(source).forEach(function (key) { return target[key] = source[key]; });\r\n                }\r\n            };\r\n            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\r\n                var source = args_1[_a];\r\n                _loop_1(source);\r\n            }\r\n            return target;\r\n        };\r\n    })();\r\n}\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Helper class for capturing stack traces.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\n// TODO:\n// - test/make it work in non-V8\n// - parse stacks into platform-independent object-arrays\nvar hasStacks = (typeof Error.captureStackTrace === \"function\");\nvar Stack = (function () {\n    function Stack(ignoreUntil) {\n        if (ignoreUntil === void 0) { ignoreUntil = Stack; }\n        /* istanbul ignore else */ // TODO: remove when testing for non-V8\n        if (hasStacks) {\n            Error.captureStackTrace(this, ignoreUntil);\n        }\n        else {\n            this.stack = \"dummy\\n<no trace>\";\n        }\n    }\n    Stack.prototype.inspect = function () {\n        var lines = this.stack.split(\"\\n\");\n        lines.shift(); // Strip the \"[object Object]\" line\n        return lines.join(\"\\n\");\n    };\n    return Stack;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Stack;\n//# sourceMappingURL=Stack.js.map\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Helper class for capturing stack traces.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\n// TODO:\n// - test/make it work in non-V8\nvar Stack_1 = __webpack_require__(17);\n/**\n * Stack trace container with optional source traces.\n *\n * Typically used for capturing traces across asynchronous calls (e.g.\n * with Promises or Events).\n */\nvar Trace = (function () {\n    function Trace(ignoreUntil) {\n        if (ignoreUntil === void 0) { ignoreUntil = Trace; }\n        this.stack = new Stack_1.default(ignoreUntil);\n    }\n    /**\n     * Assign another Trace as the source of this Trace.\n     *\n     * Note: the stack of `source` is copied to this Trace, in order to allow\n     * truncating the trace length to `Trace.traceLimit` to prevent memory\n     * exhaustion on e.g. recursive traces.\n     *\n     * @param source Trace to use as source.\n     */\n    Trace.prototype.setSource = function (source) {\n        if (!source.sources) {\n            this.sources = [source.stack];\n        }\n        else {\n            this.sources = source.sources.concat(source.stack);\n            if (this.sources.length > Trace.traceLimit) {\n                this.sources = this.sources.slice(0, Trace.traceLimit);\n            }\n        }\n    };\n    Trace.prototype.inspect = function () {\n        var result = this.stack.inspect();\n        if (this.sources) {\n            for (var i = this.sources.length - 1; i >= 0; i--) {\n                result += \"\\n  from previous:\\n\" + this.sources[i].inspect();\n            }\n        }\n        return result;\n    };\n    Trace.traceLimit = 10;\n    return Trace;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Trace;\n//# sourceMappingURL=Trace.js.map\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(setImmediate) {/**\n * Call queue for executing callbacks asynchronously.\n *\n * Prevents releasing Zalgo.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\n// TODO:\n// - simpler code\nvar util_1 = __webpack_require__(0);\nvar CallQueue = (function () {\n    function CallQueue() {\n        this.length = 0;\n        // Basically twice the number of simultaneously resolving promises\n        this._max = 1000;\n        this._first = 0;\n    }\n    /**\n     * Push a new callback to the queue.\n     * @return true when the queue still has space, false if it's now 'full'\n     */\n    CallQueue.prototype.push = function (callback, arg) {\n        this[this.length++] = callback;\n        this[this.length++] = arg;\n        return this.length < this._max;\n    };\n    /**\n     * Flush all callbacks in this queue.\n     * Note that it is 'ok' for callbacks to throw an error;\n     * the next call to flush() will flush the remainder of the queue.\n     * When this function returns, the queue will be 'reset' to its beginning.\n     */\n    CallQueue.prototype.flush = function () {\n        while (this._first < this.length) {\n            var callback = this[this._first];\n            var arg = this[this._first + 1];\n            this[this._first] = this[this._first + 1] = undefined;\n            this._first += 2;\n            callback(arg);\n        }\n        this.length = 0;\n        this._first = 0;\n    };\n    return CallQueue;\n}());\nvar Async = (function () {\n    function Async() {\n        var _this = this;\n        /* tslint:disable:member-ordering */ // trips on the arrow-function, thinks it's something public\n        this._pool = [];\n        this._ring = [new CallQueue()];\n        this._current = this._ring[0];\n        this._flusher = function () { return _this._scheduledFlush(); };\n        this._flushing = false;\n        this._scheduled = false;\n        this._scheduler = undefined;\n    }\n    /* tslint:enable:member-ordering */\n    /**\n     * Configure alternative scheduler to use.\n     * The scheduler function will be called with a flusher, which needs to be\n     * executed to flush the queue. Note: the flusher may throw an\n     * exception, if any of the callbacks on the queue throws one.\n     * This will result in another flush to be scheduled before returning.\n     *\n     * Call with `undefined` to reset the scheduler to the default (setImmediate).\n     *\n     * Example usage (this is basically the default):\n     *   setScheduler((flusher) => setImmediate(flusher));\n     */\n    Async.prototype.setScheduler = function (scheduler) {\n        /* tslint:disable:no-null-keyword */ // 'old' API told you to use `null` instead of `undefined`\n        util_1.assert(scheduler === undefined || scheduler === null || typeof scheduler === \"function\");\n        /* tslint:enable:no-null-keyword */\n        this._scheduler = scheduler;\n    };\n    Async.prototype.enqueue = function (callback, arg) {\n        if (!this._flushing && !this._scheduled) {\n            this._schedule();\n        }\n        if (!this._current) {\n            this._current = this._pool.pop();\n            if (!this._current) {\n                this._current = new CallQueue();\n            }\n            this._ring.push(this._current);\n        }\n        if (!this._current.push(callback, arg)) {\n            this._current = undefined;\n        }\n    };\n    Async.prototype.flush = function () {\n        util_1.assert(!this._flushing, \"cannot recursively flush\");\n        this._flushing = true;\n        try {\n            while (true) {\n                // Note: ring is guaranteed to have at least one queue (even though\n                // queue might be empty when flush() is e.g. called manually).\n                this._ring[0].flush();\n                // ring[0] is now guaranteed to be empty, so we could move it to\n                // the pool.\n                // However, if it's the last item remaining, better to simply\n                // leave it in the ring, saves unnecessary re-move on next\n                // enqueue.\n                if (this._ring.length === 1) {\n                    // First queue is now empty, so we can re-use it again (if\n                    // it was full last time)\n                    this._current = this._ring[0];\n                    break;\n                }\n                util_1.assert(this._current !== this._ring[0]);\n                this._pool.push(this._ring.shift());\n            }\n        }\n        finally {\n            this._flushing = false;\n            // If one of the callbacks in the queue throws an exception,\n            // (e.g. when Promise#done() detects a rejection) make sure to\n            // reschedule the remainder of the queue(s) for another iteration.\n            // This approach has the advantage of immediately allowing to stop\n            // the program in e.g. NodeJS, but also allows to continue running\n            // correctly in a browser.\n            if (this._ring[0].length > 0 && !this._scheduled) {\n                this._schedule();\n            }\n        }\n    };\n    Async.prototype._schedule = function () {\n        util_1.assert(!this._scheduled);\n        // Note: we 'fall back' to setImmediate here (instead of e.g.\n        // assigning it to the _scheduler property once), to allow\n        // setImmediate to be e.g. replaced by a mocked one (e.g. Sinon's\n        // useFakeTimers())\n        var scheduler = this._scheduler;\n        if (!scheduler) {\n            scheduler = typeof setImmediate === \"function\" ? setImmediate : setTimeout;\n        }\n        scheduler(this._flusher);\n        this._scheduled = true;\n    };\n    Async.prototype._scheduledFlush = function () {\n        // Indicate that this 'iteration' of the flush is complete.\n        this._scheduled = false;\n        this.flush();\n    };\n    return Async;\n}());\nexports.Async = Async;\nexports.async = new Async();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports.async;\n//# sourceMappingURL=async.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * TS-Promise - fast, robust, type-safe promises\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\nvar Promise_1 = __webpack_require__(3);\nexports.default = Promise_1.default;\nexports.Promise = Promise_1.Promise;\nexports.UnhandledRejectionError = Promise_1.UnhandledRejectionError;\nvar polyfill_1 = __webpack_require__(21);\nexports.polyfill = polyfill_1.default;\n// Temporary, should be moved to its own package some day\nvar BaseError_1 = __webpack_require__(2);\nexports.BaseError = BaseError_1.default;\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Polyfill implementation.\n *\n * Copyright (C) 2016 Martin Poelstra\n * License: MIT\n */\n\nvar Promise_1 = __webpack_require__(3);\nvar util_1 = __webpack_require__(0);\n/**\n * Polyfill global `Promise` instance with ts-promise version.\n * By default, it will only install a ts-promise version if no other\n * implementation is present. Use `force = true` to unconditionally replace the\n * promise implementation.\n *\n * Warning: in general, it's not really recommended to use polyfills, because\n * other libraries may e.g. use the fact that certain platform features are\n * absent to create a 'fingerprint' of a platform, and it may conflict with\n * other libraries that are trying to do the same thing.\n * If you're writing your own library, it's much better to simply directly\n * require/import ts-promise, and use its class directly.\n * However, if you're the 'end-user' (i.e. application, not a library), it may\n * be a viable solution to make Promises available on platforms that otherwise\n * don't have them.\n *\n * @param  {boolean}  force (Optional, default false) Forcibly overwrite existing Promise implementation with ts-promise version.\n * @return {boolean}        Returns true when global Promise is (now) a ts-promise (or derived class), false otherwise.\n */\nfunction polyfill(force) {\n    if (force === void 0) { force = false; }\n    // Get reference to globals (`global`, `window`, etc.)\n    var global = util_1.getGlobal();\n    if (!global) {\n        return false;\n    }\n    if (force || typeof global.Promise !== \"function\") {\n        global.Promise = Promise_1.Promise;\n        return true;\n    }\n    return global.Promise instanceof Promise_1.Promise;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = polyfill;\n//# sourceMappingURL=polyfill.js.map\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(4);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Sdk.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 22);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a38d0b43d364a03f949b","/**\n * Helper utilities.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n/**\n * Throw an Error when given condition is false.\n *\n * @param {any}    condition Condition, no-op when truthy, error thrown when falsy\n * @param {string} msg       Optional text to include in error message\n */\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg ? \"assertion failed: \" + msg : \"assertion failed\");\n    }\n}\nexports.assert = assert;\n/**\n * Return reference to the global object (if possible).\n *\n * @return {any} Reference to the global object (e.g. `window`, `global`, etc.),\n *               or `undefined` if it could not be determined.\n */\nfunction getGlobal() {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    // Otherwise, try to use `this`.\n    // We use eval-like behavior, because it will not inherit our \"use strict\",\n    // see http://stackoverflow.com/questions/3277182/how-to-get-the-global-object-in-javascript\n    var g;\n    try {\n        g = new Function(\"return this\")();\n    }\n    catch (e) {\n    }\n    return g;\n}\nexports.getGlobal = getGlobal;\n//# sourceMappingURL=util.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/util.js\n// module id = 0\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0","/**\n * Base class for custom errors.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar hasStacks = (typeof Error.captureStackTrace === \"function\");\nvar BaseError = (function (_super) {\n    __extends(BaseError, _super);\n    function BaseError(name, message) {\n        _super.call(this, message);\n        this.name = name;\n        // Note: still need to 'manually' assign .message,\n        // because engines apparently don't allow subclassing properly.\n        // https://github.com/Microsoft/TypeScript/issues/1168#issuecomment-107729088\n        this.message = message;\n        /* istanbul ignore else */ // TODO: remove when testing for non-V8\n        if (hasStacks) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        else {\n            this.stack = \"dummy\\n<no trace>\";\n        }\n    }\n    return BaseError;\n}(Error));\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = BaseError;\n//# sourceMappingURL=BaseError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/BaseError.js\n// module id = 2\n// module chunks = 0","/**\n * Promise implementation in TypeScript.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/* tslint:disable:no-unused-expression */ // prevent errors on `trace && trace(....)`\n// TODO:\n// - remove all \"called = true\"-type code in resolvers, replace by single check in _resolve()/_reject()\n// - add possibility for an unhandled-rejections-handler\n// - try to remove mangling of Error's .stack property on rejections with longTraces enabled\nvar async_1 = require(\"./async\");\nvar util_1 = require(\"./util\");\nvar Trace_1 = require(\"./Trace\");\nvar BaseError_1 = require(\"./BaseError\");\n/**\n * Thrown when a rejected promise is explicitly terminated with `.done()`.\n */\nvar UnhandledRejectionError = (function (_super) {\n    __extends(UnhandledRejectionError, _super);\n    function UnhandledRejectionError(reason, trace) {\n        _super.call(this, \"UnhandledRejectionError\", \"unhandled rejection: \" + reason);\n        this.reason = reason;\n        // TODO: Find a better way to merge the location of `.done()` in the\n        // trace, because nobody will look for this property...\n        this.trace = trace;\n        // In case we have a reason, and it has a stack: use it instead of our\n        // own stack, as it's more helpful to see where the original error was\n        // thrown, than where it was thrown inside the promise lib.\n        // In case we don't have a stack, explicitly state so, to not let people\n        // chase a problem in the promise lib that isn't there...\n        var stack = this.reason && typeof this.reason === \"object\" && this.reason.stack;\n        if (typeof stack !== \"string\") {\n            stack = String(reason);\n        }\n        this.stack = \"UnhandledRejectionError: \" + stack;\n    }\n    return UnhandledRejectionError;\n}(BaseError_1.default));\nexports.UnhandledRejectionError = UnhandledRejectionError;\nvar trace = undefined;\nvar longTraces = false;\nvar State;\n(function (State) {\n    State[State[\"Pending\"] = 0] = \"Pending\";\n    State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n    State[State[\"Rejected\"] = 2] = \"Rejected\";\n})(State || (State = {}));\nfunction internalResolver(fulfill, reject) {\n    /* no-op, sentinel value */\n}\ninternalResolver(undefined, undefined); // just for code coverage...\nfunction noop() {\n    /* no-op */\n}\nvar getThenError = {\n    error: undefined,\n};\nfunction wrapNonError(a) {\n    // This is basically a marker for the places where we need to check\n    // handling of errors for .error() support.\n    // A no-op for now.\n    return a;\n}\nvar dummyDoneTrace = new Trace_1.default();\n/**\n * Currently unwrapping promise, while running one of its then-callbacks.\n * Used to set the source of newly created promises.\n * We guarantee that at most one callback of a then() is running at any time.\n */\nvar unwrappingPromise = undefined;\nvar promiseIdCounter = 0;\n/**\n * Fast, robust, type-safe promise implementation.\n */\nvar Promise = (function () {\n    /**\n     * Create new Promise.\n     *\n     * Pass a callback that will receive a `resolve()` and `reject()` function\n     * to seal the promise's fate.\n     *\n     * @param  resolver Called with resolve and reject functions\n     */\n    function Promise(resolver) {\n        var _this = this;\n        this._id = promiseIdCounter++;\n        this._state = 0 /* Pending */;\n        this._result = undefined; // Can be fulfillment value or rejection reason\n        this._handlers = undefined;\n        this._trace = undefined;\n        trace && trace(this, \"construct\");\n        if (longTraces) {\n            this._trace = new Trace_1.default(Promise);\n            if (unwrappingPromise) {\n                this._setSource(unwrappingPromise);\n            }\n        }\n        if (resolver === internalResolver) {\n            // Internally created promises pass 'internalResolver', signalling\n            // that resolving will be done by calling private methods on the\n            // Promise. This saves having to create 2 closures.\n            return;\n        }\n        if (typeof resolver !== \"function\") {\n            throw new TypeError(\"Promise resolver is not a function\");\n        }\n        var called = false;\n        try {\n            resolver(function (y) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,\n                // run `[[Resolve]](promise, y)`\n                called = true;\n                _this._resolve(y);\n            }, function (r) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,\n                // reject `promise` with `r`\n                called = true;\n                _this._reject(wrapNonError(r));\n            });\n        }\n        catch (e) {\n            // 2.3.3.3.4: If calling `then` throws an exception `e`,\n            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.\n            if (!called) {\n                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.\n                called = true;\n                this._reject(wrapNonError(e));\n            }\n        }\n    }\n    /**\n     * Run either `onFulfilled` or `onRejected` callbacks when the promise is\n     * resolved. Returns another promise for the return value of such a\n     * callback.\n     *\n     * The callback will always be called at most once, and always\n     * asynchronously (i.e. some time after e.g. the `resolver` passed to the\n     * constructor has resolved the promise).\n     *\n     * Any error thrown or rejected promise returned from a callback will cause\n     * the returned promise to be rejected with that error.\n     *\n     * If either or both callbacks are missing, the fulfillment or rejection is\n     * passed on unmodified.\n     *\n     * Use `.catch(onRejected)` instead of `.then(undefined, onRejected)` for\n     * stronger typing, better readability, and more functionality (predicates).\n     *\n     * @param onFulfilled Callback called with promise's fulfillment\n     *                    value iff promise is fulfilled. Callback can return\n     *                    another value or promise for a value.\n     * @param onRejected  Optional callback called with promise's rejection\n     *                    reason iff promise is rejected. Callback can return\n     *                    another value or promise for a value.\n     * @return Promise for value returned by either of the callbacks\n     */\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n        trace && trace(this, \"then(\" + typeof onFulfilled + \", \" + typeof onRejected + \")\");\n        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== \"function\" ||\n            this._state === 2 /* Rejected */ && typeof onRejected !== \"function\") {\n            // Optimization: handler is short-circuited, so pass the result (value/rejection)\n            // through unmodified.\n            // The typecast is safe, because we either have a fulfillment value\n            // but no handler that could change the type, or a rejection without a\n            // handler that could change it, so R === T in this case.\n            // TODO: verify whether longTraces etc still work as expected\n            return this;\n        }\n        // Construct new Promise, but use subclassed constructor, if any\n        var slave = new (Object.getPrototypeOf(this).constructor)(internalResolver);\n        slave._setSource(this);\n        this._enqueue(onFulfilled, onRejected, slave, undefined);\n        return slave;\n    };\n    /**\n     * Run either `onFulfilled` or `onRejected` callbacks when the promise is\n     * resolved. If the callback throws an error or the returned value resolves\n     * to a rejection, the library will (asynchronously) throw an\n     * `UnhandledRejectionError` with that error.\n     *\n     * The callback will always be called at most once, and always\n     * asynchronously (i.e. some time after e.g. the `resolver` passed to the\n     * constructor has resolved the promise).\n     *\n     * @param onFulfilled Optional callback called with promise's fulfillment\n     *                    value iff promise is fulfilled. Any error thrown or\n     *                    rejection returned will cause an UnhandledRejectionError\n     *                    to be thrown.\n     * @param onRejected  Optional callback called with promise's rejection\n     *                    reason iff promise is rejected. Any error thrown or\n     *                    rejection returned will cause an UnhandledRejectionError\n     *                    to be thrown.\n     */\n    Promise.prototype.done = function (onFulfilled, onRejected) {\n        trace && trace(this, \"done(\" + typeof onFulfilled + \", \" + typeof onRejected + \")\");\n        if (this._state === 1 /* Fulfilled */ && typeof onFulfilled !== \"function\") {\n            return;\n        }\n        var doneTrace = dummyDoneTrace;\n        if (longTraces) {\n            doneTrace = new Trace_1.default();\n            if (this._trace) {\n                doneTrace.setSource(this._trace);\n            }\n        }\n        this._enqueue(onFulfilled, onRejected, undefined, doneTrace);\n    };\n    /**\n     * Catch only errors that match predicate in case promise is rejected.\n     * Predicate can be an Error (sub-)class, array of Error classes, or a\n     * function that can return true to indicate a match.\n     *\n     * The returned promise is resolved with the output of the callback, so it\n     * is possible to re-throw the error, but also to return a 'replacement'\n     * value that should be used instead.\n     *\n     * @param predicate   Optional Error class, array of Error classes or match\n     *                    function\n     * @param onRejected  Callback called with promise's rejection reason iff\n     *                    promise is rejected. Callback can return another value\n     *                    or promise for a value.\n     * @return Promise for original value, or 'replaced' value in case of error\n     */\n    Promise.prototype.catch = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        if (arguments.length === 1) {\n            var onRejected = arguments[0];\n            return this.then(undefined, onRejected);\n        }\n        else {\n            var predicate_1 = arguments[0];\n            var onRejected_1 = arguments[1];\n            return this.then(undefined, function (reason) {\n                var match = false;\n                if (typeof predicate_1 === \"function\") {\n                    if (predicate_1.prototype instanceof Error || predicate_1 === Error) {\n                        match = reason instanceof predicate_1;\n                    }\n                    else {\n                        match = predicate_1(reason);\n                    }\n                }\n                else if (Array.isArray(predicate_1)) {\n                    for (var i = 0; i < predicate_1.length; i++) {\n                        if (reason instanceof predicate_1[i]) {\n                            match = true;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    throw new TypeError(\"invalid predicate to .catch(), got \" + typeof predicate_1);\n                }\n                if (match) {\n                    return onRejected_1(reason);\n                }\n                return Promise.reject(reason);\n            });\n        }\n    };\n    /**\n     * Asynchronous equivalent of try { } finally { }.\n     *\n     * Runs `handler` when promise resolves (fulfilled or rejected).\n     * Handler is passed the current promise (which is guaranteed to be\n     * resolved), and can be interrogated with e.g. `isFulfilled()`, `.value()`,\n     * etc.\n     *\n     * When `handler` returns `undefined` or its promise is fulfilled, the\n     * promise from `finally()` is resolved to the original promise's resolved\n     * value or rejection reason.\n     * If `handler` throws an error or returns a rejection, the result of\n     * `finally()` will be rejected with that error.\n     *\n     * Example:\n     * someLenghtyOperation().finally((result) => {\n     *   if (result.isFulfilled()) {\n     *     console.log(\"succeeded\");\n     *   } else {\n     *     console.log(\"failed\", result.reason());\n     *   }\n     * });\n     *\n     * @param  handler [description]\n     * @return promise with same value/reason as this one, after `handler`'s\n     *         result (if any) has been fulfilled, or a promise rejected with\n     *         `handler`'s error if it threw one or returned a rejection.\n     */\n    Promise.prototype.finally = function (handler) {\n        var _this = this;\n        var runner = function () { return handler(_this); };\n        return this.then(runner, runner).return(this);\n    };\n    /**\n     * @return `true` when promise is fulfilled, `false` otherwise.\n     */\n    Promise.prototype.isFulfilled = function () {\n        return this._state === 1 /* Fulfilled */;\n    };\n    /**\n     * @return `true` when promise is rejected, `false` otherwise.\n     */\n    Promise.prototype.isRejected = function () {\n        return this._state === 2 /* Rejected */;\n    };\n    /**\n     * @return `true` when promise is pending (may be resolved to another pending\n     *         promise), `false` otherwise.\n     */\n    Promise.prototype.isPending = function () {\n        return this._state === 0 /* Pending */;\n    };\n    /**\n     * @return Fulfillment value if fulfilled, otherwise throws an error.\n     */\n    Promise.prototype.value = function () {\n        if (!this.isFulfilled()) {\n            throw new Error(\"Promise is not fulfilled\");\n        }\n        return this._result;\n    };\n    /**\n     * @return Rejection reason if rejected, otherwise throws an error.\n     */\n    Promise.prototype.reason = function () {\n        if (!this.isRejected()) {\n            throw new Error(\"Promise is not rejected\");\n        }\n        return this._result;\n    };\n    /**\n     * @return A human-readable representation of the promise and its status.\n     */\n    Promise.prototype.inspect = function () {\n        return this.toString();\n    };\n    /**\n     * @return A human-readable representation of the promise and its status.\n     */\n    Promise.prototype.toString = function () {\n        var state;\n        switch (this._state) {\n            case 0 /* Pending */:\n                state = \"pending\";\n                break;\n            case 1 /* Fulfilled */:\n                state = \"fulfilled\";\n                break;\n            case 2 /* Rejected */:\n                state = \"rejected\";\n                break;\n            /* istanbul ignore next */\n            default: state = \"unknown\";\n        }\n        return \"[Promise \" + this._id + \": \" + state + \"]\";\n    };\n    /**\n     * Create a promise that resolves with the same value of this promise, after\n     * `ms` milliseconds. The timer will start when the current promise is\n     * resolved.\n     * If the current promise is rejected, the resulting promise is also\n     * rejected, without waiting for the timer.\n     *\n     * @param ms Number of milliseconds to wait before resolving\n     * @return Promise that fulfills `ms` milliseconds after this promise fulfills\n     */\n    Promise.prototype.delay = function (ms) {\n        return this.then(function (value) {\n            return new Promise(function (resolve) {\n                setTimeout(function () { return resolve(value); }, ms);\n            });\n        });\n    };\n    /**\n     * Return a promise that resolves to `value` after this promise is\n     * fulfilled.\n     * Returned promise is rejected if this promise is rejected.\n     *\n     * Equivalent to `.then(() => value)`.\n     *\n     * @param value Value or promise for value of returned promise\n     * @return Promise resolved to value after this promise fulfills\n     */\n    Promise.prototype.return = function (value) {\n        if (value === undefined) {\n            // In TypeScript, we often need to 'force' a promise to become a\n            // void promise, so this is a common case. Prevents the closure.\n            // (Note: the any cast is just because TS assumes were going to\n            // return an R, but we're in fact going to return a void.)\n            return this.then(noop);\n        }\n        return this.then(function () { return value; });\n    };\n    /**\n     * Return a promise that is rejected with `reason` after this promise is\n     * fulfilled.\n     * If this promise is rejected, returned promise will rejected with that\n     * error instead.\n     *\n     * Equivalent to `.then(() => { throw value; })`.\n     *\n     * @param reason Error reason to reject returned promise with\n     * @return Promise rejected with `reason` after this promise fulfills\n     */\n    Promise.prototype.throw = function (reason) {\n        return this.then(function () { return Promise.reject(reason); });\n    };\n    /**\n     * Create an immediately resolved promise (in case of a 'normal' value), or\n     * a promise that 'follows' another `Thenable` (e.g. a Promise from another\n     * library).\n     *\n     * @param value Value (or Thenable for value) for returned promise\n     * @return Promise resolved to `value`\n     */\n    Promise.resolve = function (value) {\n        var p = new Promise(internalResolver);\n        p._resolve(value);\n        return p;\n    };\n    /**\n     * Create an immediately rejected promise.\n     *\n     * Note: to create a rejected promise of a certain type, use e.g.\n     * `Promise.reject<number>(myError)`\n     *\n     * @param reason Error object to set rejection reason\n     * @return Promise resolved to rejection `reason`\n     */\n    Promise.reject = function (reason) {\n        var p = new Promise(internalResolver);\n        p._reject(reason);\n        return p;\n    };\n    /**\n     * Return a promise for an array of all resolved input promises (or values).\n     * If any of the input promises is rejected, the returned promise is\n     * rejected with that reason.\n     * When passing an empty array, the promises is immediately resolved to an\n     * empty array.\n     *\n     * @param thenables Array of values or promises for them\n     * @return promise that resolves with array of all resolved values\n     */\n    Promise.all = function (thenables) {\n        return new Promise(function (resolve, reject) {\n            util_1.assert(Array.isArray(thenables), \"thenables must be an Array\");\n            if (thenables.length === 0) {\n                resolve([]);\n                return;\n            }\n            var result = new Array(thenables.length);\n            var remaining = thenables.length;\n            for (var i = 0; i < thenables.length; i++) {\n                follow(thenables[i], i);\n            }\n            function follow(t, index) {\n                var slave = t instanceof Promise ? t : Promise.resolve(t);\n                slave.done(function (v) {\n                    result[index] = v;\n                    remaining--;\n                    if (remaining === 0) {\n                        resolve(result);\n                    }\n                }, function (reason) { return reject(reason); });\n            }\n        });\n    };\n    /**\n     * Return a promise that resolves to the fulfillment or rejection of the\n     * first input promise that resolves.\n     * When passing an empty array, the promise will never resolve.\n     *\n     * @param thenables Array of values or promises for them\n     * @return promise that resolves to first resolved input promise\n     */\n    Promise.race = function (thenables) {\n        return new Promise(function (resolve, reject) {\n            util_1.assert(Array.isArray(thenables), \"thenables must be an Array\");\n            for (var i = 0; i < thenables.length; i++) {\n                var t = thenables[i];\n                var slave = t instanceof Promise ? t : Promise.resolve(t);\n                Promise.resolve(slave).done(resolve, reject);\n            }\n        });\n    };\n    /**\n     * Create tuple of a promise and its resolve and reject functions.\n     *\n     * It is generally better (and slightly faster) to use the Promise\n     * constructor to create a promise, as that will also catch any exception\n     * thrown while running the resolver.\n     *\n     * A Deferred can be useful in some scenarios though, e.g. when working with\n     * timers, protocol request/response pairs, etc.\n     *\n     * @return Deferred object, containing unresolved promise and its\n     *         resolve/reject functions\n     */\n    Promise.defer = function () {\n        var resolve;\n        var reject;\n        var p = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        return {\n            promise: p,\n            reject: reject,\n            resolve: resolve,\n        };\n    };\n    /**\n     * Create a promise that resolves to the given value (or promise for a\n     * value) after `ms` milliseconds. The timer will start when the given value\n     * is resolved.\n     * If the input value is a rejected promise, the resulting promise is also\n     * rejected, without waiting for the timer.\n     *\n     * @param value Value or promise for value to be delayed\n     * @param ms Number of milliseconds to wait before resolving\n     * @return Promise that fulfills `ms` milliseconds after given (promise for)\n     *         value is fulfilled\n     */\n    Promise.delay = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i - 0] = arguments[_i];\n        }\n        if (arguments[1] === undefined) {\n            // delay(ms)\n            var ms_1 = arguments[0];\n            return new Promise(function (resolve) {\n                setTimeout(resolve, ms_1);\n            });\n        }\n        // delay(value, ms)\n        return Promise.resolve(arguments[0]).delay(arguments[1]);\n    };\n    /**\n     * Enable or disable long stack trace tracking on promises.\n     *\n     * This allows tracing a promise chain through the various asynchronous\n     * actions in a program. For example, when a promise is rejected, the last\n     * few locations of any preceding promises are included in the error's stack\n     * trace.\n     *\n     * Note: it is possible to enable/disable long tracing at runtime.\n     *\n     * When chaining off of a promise that was created while tracing was enabled\n     * (e.g. through `.then()`), all children will also have long traces, even\n     * when tracing is turned off. This allows to trace just some promise paths.\n     *\n     * Tracing is disabled by default as it incurs a memory and performance\n     * overhead, although it's still faster with tracing than some major\n     * promise libraries without tracing, so don't worry too much about it.\n     *\n     * @param enable Set to true to enable long traces, false to disable\n     */\n    Promise.setLongTraces = function (enable) {\n        longTraces = enable;\n    };\n    /**\n     * Set trace function that is called for internal state changes of a\n     * promise.\n     * Call with `undefined` or `null` to disable such tracing (this is the\n     * default).\n     *\n     * @param tracer Callback called for various stages during lifetime of a promise\n     */\n    Promise.setTracer = function (tracer) {\n        if (typeof tracer === \"function\") {\n            trace = tracer;\n        }\n        else {\n            trace = undefined;\n        }\n    };\n    /**\n     * Recursively flush the async callback queue until all `.then()` and\n     * `.done()` callbacks for fulfilled and rejected Promises have been called.\n     * Useful in e.g. unit tests to advance program state to the next 'tick'.\n     *\n     * Note that if e.g. `.done()` encounters a rejected promise, `flush()` will\n     * immediately throw an error (e.g. `UnhandledRejectionError`).\n     * It is safe to call `flush()` again afterwards, but it will also be called\n     * automatically by the async queue on the next 'real' tick.\n     *\n     * It is an error to call `flush()` while it is already running (e.g. from\n     * a `.then()` callback).\n     */\n    Promise.flush = function () {\n        async_1.default.flush();\n    };\n    Promise.prototype._setSource = function (source) {\n        if (!this._trace || !source._trace) {\n            return;\n        }\n        this._trace.setSource(source._trace);\n    };\n    Promise.prototype._resolve = function (x) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        if (!x) {\n            // Shortcut for falsy values, most notably void-Promises\n            // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`\n            this._fulfill(x);\n            return;\n        }\n        // 2.3.1: If promise and x refer to the same object, reject promise with a TypeError as the reason.\n        if (this === x) {\n            this._reject(new TypeError(\"cannot resolve Promise to self\"));\n            return;\n        }\n        // 2.3.2: If `x` is a promise, adopt its state\n        if (x instanceof Promise) {\n            x._setSource(this);\n            if (x._state === 0 /* Pending */) {\n                // 2.3.2.1: If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.\n                this._followPromise(x);\n            }\n            else if (x._state === 1 /* Fulfilled */) {\n                // 2.3.2.2: If/when `x` is fulfilled, fulfill `promise` with the same value.\n                this._fulfill(x._result);\n            }\n            else {\n                // 2.3.2.3: If/when `x` is rejected, reject `promise` with the same reason.\n                this._reject(x._result);\n            }\n            return;\n        }\n        // 2.3.3: Otherwise, if `x` is an object or function,\n        if (typeof x === \"object\" || typeof x === \"function\") {\n            // 2.3.3.1: Let `then` be `x.then`\n            var then = this._tryGetThen(x);\n            // 2.3.3.2: If retrieving the property `x.then` results in a thrown\n            // exception `e`, reject `promise` with `e` as the reason.\n            if (then === getThenError) {\n                this._reject(wrapNonError(getThenError.error));\n                return;\n            }\n            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,\n            //          first argument `resolvePromise`, and second argument `rejectPromise`\n            if (typeof then === \"function\") {\n                this._followThenable(x, then);\n                return;\n            }\n        }\n        // 2.3.4: If `x` is not an object or function, fulfill `promise` with `x`\n        this._fulfill(x);\n    };\n    Promise.prototype._tryGetThen = function (x) {\n        try {\n            // 2.3.3.1: Let `then` be `x.then`\n            var then = x.then;\n            return then;\n        }\n        catch (e) {\n            // 2.3.3.2: If retrieving the property `x.then` results in a thrown\n            // exception `e`, reject `promise` with `e` as the reason.\n            getThenError.error = e;\n            return getThenError;\n        }\n    };\n    Promise.prototype._fulfill = function (value) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_fulfill(\" + typeof value + \")\");\n        // 2.1.2.2 When fulfilled, a promise must have a value, which must not change.\n        this._state = 1 /* Fulfilled */;\n        this._result = value;\n        this._flush();\n    };\n    Promise.prototype._reject = function (reason) {\n        var _this = this;\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_reject(\" + reason + \")\");\n        // 2.1.3.2 When rejected, a promise must have a reason, which must not change.\n        this._state = 2 /* Rejected */;\n        this._result = reason;\n        if (this._trace && this._result instanceof Error && !this._result.trace) {\n            this._result.trace = this._trace;\n            // TODO: Meh, this always accesses '.stack', which is supposed to be expensive\n            var originalStack = this._result.stack;\n            // Stack may be undefined if e.g. a Stack Overflow occurred\n            if (originalStack) {\n                Object.defineProperty(this._result, \"stack\", {\n                    enumerable: false,\n                    get: function () { return originalStack + \"\\n  from Promise at:\\n\" + _this._trace.inspect(); },\n                });\n            }\n        }\n        this._flush();\n    };\n    Promise.prototype._followPromise = function (slave) {\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_follow([Promise \" + slave._id + \"])\");\n        slave._enqueue(undefined, undefined, this, undefined);\n    };\n    Promise.prototype._followThenable = function (slave, then) {\n        var _this = this;\n        // 2.1.2.1 When fulfilled, a promise must not transition to any other state.\n        // 2.1.3.1 When rejected, a promise must not transition to any other state.\n        util_1.assert(this._state === 0 /* Pending */);\n        trace && trace(this, \"_follow([Thenable])\");\n        var called = false;\n        try {\n            // 2.3.3.3: If `then` is a function, call it with `x` as `this`,\n            //          first argument `resolvePromise`, and second argument `rejectPromise`\n            then.call(slave, function (y) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.1: If/when `resolvePromise` is called with value `y`,\n                // run `[[Resolve]](promise, y)`\n                called = true;\n                _this._resolve(y);\n            }, function (r) {\n                if (called) {\n                    // 2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,\n                    // or multiple calls to the same argument are made, the first call\n                    // takes precedence, and any further calls are ignored.\n                    return;\n                }\n                // 2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,\n                // reject `promise` with `r`\n                called = true;\n                _this._reject(wrapNonError(r));\n            });\n        }\n        catch (e) {\n            // 2.3.3.3.4: If calling `then` throws an exception `e`,\n            // 2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.\n            if (!called) {\n                // 2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.\n                called = true;\n                this._reject(wrapNonError(e));\n            }\n        }\n    };\n    Promise.prototype._enqueue = function (onFulfilled, onRejected, slave, done) {\n        var h = {\n            promise: this,\n            onFulfilled: onFulfilled,\n            onRejected: onRejected,\n            slave: slave,\n            done: done,\n        };\n        if (this._state !== 0 /* Pending */) {\n            async_1.default.enqueue(Promise._unwrapper, h);\n        }\n        else {\n            if (!this._handlers) {\n                this._handlers = [h];\n            }\n            else {\n                var i = this._handlers.length;\n                this._handlers[i] = h;\n            }\n        }\n    };\n    /**\n     * Schedule any pending .then()/.done() callbacks and follower-promises to\n     * be called/resolved.\n     * Clears our queue, any callbacks/followers attached after this will be\n     * scheduled without going through our handlers queue.\n     */\n    Promise.prototype._flush = function () {\n        if (!this._handlers) {\n            return;\n        }\n        var i = 0;\n        var h = this._handlers;\n        var l = h.length;\n        this._handlers = undefined;\n        while (i < l) {\n            // Note: we enqueue every single callback/follower separately,\n            // because e.g. .done() might throw and we need to ensure we can\n            // continue after that. async handles that for us.\n            // And because the queue needs to be processed in-order, we can't\n            // 'filter' the non-callback operations out either.\n            async_1.default.enqueue(Promise._unwrapper, h[i++]);\n        }\n    };\n    /**\n     * 'Unwrap' a promise handler, i.e. call a .then()/.done() callback, or\n     * resolve a promise that's following us.\n     * @param handler The handler being processed\n     */\n    Promise.prototype._unwrap = function (handler) {\n        var callback = this._state === 1 /* Fulfilled */ ? handler.onFulfilled : handler.onRejected;\n        if (handler.done) {\n            // Unwrap .done() callbacks\n            trace && trace(this, \"_unwrap()\");\n            if (typeof callback !== \"function\") {\n                // No callback: if we ended in a rejection, throw it, otherwise\n                // all was good.\n                if (this._state === 2 /* Rejected */) {\n                    var unhandled = new UnhandledRejectionError(this._result, handler.done);\n                    // TODO Allow intercepting these\n                    // Leave the comment after the throw: may show up in source line in node\n                    throw unhandled; // Unhandled exception caught by .done()\n                }\n                return;\n            }\n            util_1.assert(!unwrappingPromise);\n            unwrappingPromise = this;\n            try {\n                var result = callback(this._result);\n                if (result) {\n                    // May be a thenable, need to start following it...\n                    var p = (result instanceof Promise) ? result : Promise.resolve(result);\n                    p.done(); // Ensure it throws as soon as it's rejected\n                }\n                unwrappingPromise = undefined;\n            }\n            catch (e) {\n                unwrappingPromise = undefined;\n                // Wrap in UnhandledRejectionError\n                var unhandled = new UnhandledRejectionError(e, handler.done);\n                // TODO Allow intercepting these\n                // Leave the comment after the throw: may show up in source line in node\n                throw unhandled; // Unhandled exception caught by .done()\n            }\n            return;\n        }\n        // Unwrap .then() callbacks, or resolve 'parent' promise\n        //\n        // Three scenarios are handled here:\n        // 1. An onFulfilled callback was registered and promise is fulfilled,\n        //    or onRejected callback was registered and promise is rejected\n        //    -> callback is a function, slave is the promise that was returned\n        //       from the .then() call, so resolve slave with outcome of callback\n        // 2. An onFulfilled callback was registered but promise is rejected,\n        //    or onRejected callback was registered but promise is fulfilled\n        //    -> callback is not a function (typically `undefined`), slave is\n        //       promise that was returned from the .then() call, so resolve it\n        //       with our own result (thereby 'skipping' the .then())\n        // 3. Another promise attached itself on our 'callback queue' to be\n        //    resolved when we do (i.e. its fate is determined by us)\n        //    -> callbacks will both be undefined, slave is that other promise\n        //       that wants to be resolved with our result\n        var slave = handler.slave;\n        trace && trace(this, \"_unwrap(\" + slave._id + \")\");\n        if (typeof callback === \"function\") {\n            // Case 1\n            util_1.assert(!unwrappingPromise);\n            unwrappingPromise = slave;\n            try {\n                // 2.2.5 handlers must be called as functions\n                slave._resolve(callback(this._result));\n            }\n            catch (e) {\n                slave._reject(wrapNonError(e));\n            }\n            unwrappingPromise = undefined;\n        }\n        else {\n            // Case 2 and 3\n            if (this._state === 1 /* Fulfilled */) {\n                slave._fulfill(this._result);\n            }\n            else {\n                slave._reject(this._result);\n            }\n        }\n    };\n    /**\n     * Helper for unwrapping promise handler.\n     * It's not a closure so it's cheap to schedule, and because it directly\n     * calls the _unwrap() method on a promise, it's (way) faster than having to\n     * use e.g. .call().\n     * @param handler The handler being processed\n     */\n    Promise._unwrapper = function (handler) {\n        handler.promise._unwrap(handler);\n    };\n    return Promise;\n}());\nexports.Promise = Promise;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Promise;\n//# sourceMappingURL=Promise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/Promise.js\n// module id = 3\n// module chunks = 0","import * as SDK from './lib/base';\n\nexport = SDK;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/global/window.js\n// module id = 5\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 6\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 7\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nvar global = require(\"global\");\nexports.setImmediate = global.setImmediate;\nexports.clearImmediate = global.clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 8\n// module chunks = 0","import http from './http';\nimport browser from './browser';\nimport effects from './effects';\nimport listen from './event';\nimport storage from './storage';\nimport * as utils from './utils';\n\nexport {\n  browser,\n  effects,\n  http,\n  listen,\n  storage,\n  utils\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/base.ts","const getBrowserInfo = () => {\n  const ua: string = navigator.userAgent.toLowerCase();\n  let M: any = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || [];\n  let tem: any = M;\n\n  let os: string = 'Windows';\n\n  switch (true) {\n    case ua.indexOf('Win') > -1:\n      os = 'Windows';\n      break;\n    case ua.indexOf('Mac') > -1:\n      os = 'MacOS';\n      break;\n    case ua.indexOf('X11') > -1:\n      os = 'UNIX';\n      break;\n    case ua.indexOf('Linux') > -1:\n      os = 'Linux';\n      break;\n  }\n\n  if (/trident/i.test(M[1])) {\n    tem = /\\brv[ :]+(\\d+)/g.exec(ua) || [];\n    return {\n      name: 'IE ',\n      version: (tem[1] || ''),\n      os: os\n    };\n  }\n\n  if (M[1] === 'chrome') {\n    tem = ua.match(/\\bOPR\\/(\\d+)/);\n    if (tem !== null) {\n      return {\n        name: 'Opera',\n        version: tem[1],\n        os: os\n      };\n    }\n  }\n\n  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];\n  if ((tem = ua.match(/version\\/(\\d+)/i)) !== null) {\n    M.splice(1, 1, tem[1]);\n  }\n\n  return {\n    name: M[0],\n    version: M[1],\n    os: os\n  };\n};\n\nconst browser = getBrowserInfo();\nconst name = browser.name.toLowerCase();\nconst version = browser.version;\nconst os = browser.os\n\nexport default {\n  name,\n  version,\n  os\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/browser.ts","var effects = <any>{};\n\neffects.fadeIn = (element: any, speed: number = 0) => {\n  // console.trace();\n  speed = speed + 0.1;\n\n  element.style.opacity = speed;\n  element.style.display = 'block';\n\n  if (speed < 1) {\n    setTimeout(() => {\n      effects.fadeIn(element, speed);\n    }, 10);\n  }\n};\n\neffects.fadeOut = (element: any, speed: number = 1) => {\n  // console.trace();\n  const timer = setInterval(function () {\n      if (speed <= 0.0) {\n        clearInterval(timer);\n      }\n      element.style.opacity = speed;\n      element.style.display = 'none';\n      element.style.filter = 'alpha(opacity=' + speed * 100 + \")\";\n      speed -= 0.1;\n  }, 25);\n};\n\nexport default effects;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/effects.ts","const listen = (args: any = {}) => {\n  const element = args.element || {};\n  const eventName = args.eventName || {};\n  const callback = args.callback || {};\n  const capture = args.capture || false;\n  eventName.split(' ').forEach((e: any) => element.addEventListener((e), (callback), (capture)));\n};\n\nexport default listen;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/event.ts","import Promise from 'ts-promise';\n\nconst HttpObj = {\n  request: (args: any = {}) => {\n    // {method, url, data, doneCallback, errorCallback, timeout = 30}\n    let params: string = '';\n    let uri: string = args.url || '';\n    let data: object = args.data || '';\n    let method: string = args.method || 'get';\n    const doneCallback: any = args.doneCallback || (() => {});\n    const errorCallback: any = args.errorCallback || (() => {});\n    const timeout: string = args.timeout || '30';\n    let options: object = {};\n\n    method = method.toLowerCase();\n\n    if (window.fetch) {\n      // 支持fetch\n      switch (method) {\n        case 'post':\n          // TODO:\n          options = {\n            mode: 'no-cors',\n            method: 'post',\n            credentials: 'include',\n            headers: headers(),\n            body: splitUrl(data)\n          };\n          break;\n        default:\n          params = typeof data === 'object' ? '?' + splitUrl(data) : '';\n          uri = uri + params;\n          options = {\n            mode: 'no-cors',\n            credentials: 'include',\n          };\n          break;\n      }\n      // 发起fetch请求\n      fetch(uri, options)\n        .then(HttpF.checkStatus)\n        .then(HttpF.parseJson)\n        .then(doneCallback)\n        .catch(errorCallback);\n    } else {\n      // 不支持fetch\n      switch (method) {\n        case 'post':\n          makeRequest({\n            method: method,\n            url: uri,\n            params: data,\n            headers: headers()\n          })\n          .then(doneCallback)\n          .catch(errorCallback);\n          break;\n        default:\n          params = typeof data === 'object' ? '?' + splitUrl(data) : '';\n          uri = uri + params;\n          makeRequest({\n            method: method,\n            url: uri,\n            params: data,\n            headers: headers()\n          })\n          .then(doneCallback)\n          .catch(errorCallback);\n          break;\n      }\n    }\n  },\n\n  get: (uri: string = '', doneCallback: any) => {\n    if (typeof uri !== 'string') {\n      return 'uri invalid';\n    }\n\n    if (window.fetch) {\n      // 支持fetch\n      const options: object = {\n        mode: 'no-cors',\n        credentials: 'include',\n      };\n      // 发起fetch请求\n      fetch(uri, options)\n        .then(HttpF.checkStatus)\n        .then(HttpF.parseJson)\n        .then(doneCallback)\n        .catch((err) => {\n          return err;\n        });\n    } else {\n      // 不支持fetch\n      makeRequest({\n        method: 'get',\n        url: uri,\n        params: '',\n        headers: headers()\n      })\n      .then(doneCallback)\n      .catch((err) => {\n        return err;\n      });\n    }\n  },\n\n  post: (args: any = {}) => {\n    let params: string = '';\n    let uri: string = args.url || '';\n    let data: object = args.data || '';\n    let method: string = args.method || 'get';\n    const doneCallback: any = args.doneCallback || (() => {});\n    const errorCallback: any = args.errorCallback || (() => {});\n    const timeout: string = args.timeout || '30';\n    let options: object = {};\n\n    method = method.toLowerCase();\n\n    if (window.fetch) {\n      // 支持fetch\n      options = {\n        mode: 'no-cors',\n        method: 'post',\n        credentials: 'include',\n        headers: headers(),\n        body: splitUrl(data)\n      };\n      // 发起fetch请求\n      fetch(uri, options)\n        .then(HttpF.checkStatus)\n        .then(HttpF.parseJson)\n        .then(doneCallback)\n        .catch(errorCallback);\n    } else {\n      // 不支持fetch\n      makeRequest({\n        method: method,\n        url: uri,\n        params: data,\n        headers: headers()\n      })\n      .then(doneCallback)\n      .catch(errorCallback);\n    }\n  }\n};\n\n/**\n * 处理请求参数\n *\n * @type {Object}\n */\nconst HttpF = {\n  parseJson: (response: any) => {\n    return response.json();\n  },\n\n  checkStatus: (response: any) => {\n    if (response.ok) {\n      return response;\n    } else {\n      let error: any = new Error(response.statusText);\n      error.response = response;\n      throw error;\n    }\n  }\n}\n\n/**\n * XMLHttpRequest请求，使用Promise特性\n */\nfunction makeRequest(opts: any) {\n  return new Promise(function(resolve: any, reject: any) {\n    let xhr = new XMLHttpRequest();\n    xhr.open(opts.method, opts.url);\n    xhr.onload = function(res: any) {\n      if (res.status >= 200 && res.status < 300) {\n        resolve(JSON.parse(xhr.response));\n      } else {\n        reject({\n          status: res.status,\n          statusText: xhr.statusText\n        });\n      }\n    };\n    xhr.onerror = function(res: any) {\n      reject({\n        status: res.status,\n        statusText: xhr.statusText\n      });\n    };\n    if (opts.headers) {\n      Object.keys(opts.headers).forEach(function(key) {\n        xhr.setRequestHeader(key, opts.headers[key]);\n      });\n    }\n    let params: object | string = opts.params;\n    // 转换对象为字符串\n    if (params && typeof params === 'object') {\n      params = splitUrl(params);\n    }\n    xhr.send(params);\n  });\n}\n\n// 拼接URI\nfunction splitUrl(obj: any) {\n  return Object.keys(obj).map(k => `${encodeURIComponent(k)}=${encodeURIComponent(obj[k])}`).join('&');\n}\n\nfunction headers(): object {\n  return {\n    'Accept': 'application/json, text/plain, */*',\n    'Content-type': 'application/x-www-form-urlencoded; charset=UTF-8'\n  };\n}\n\nconst http = {\n  get: HttpObj.get,\n  post: HttpObj.post,\n  request: HttpObj.request\n}\n\nexport default http;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/http.ts","import '../polyfill/object-assign';\n\nconst storage = {\n  set: (obj: any = {}) => {\n    /* 格式: {key1: value1, key2: {k: v}} */\n    if (!obj) {\n      console.warn('object invalid');\n      return;\n    }\n\n    for (let key in obj) {\n      let value: string = obj[key];\n\n      if (!key) {\n        console.warn('key invalid');\n        return;\n      }\n\n      if (typeof value === 'object') {\n        value = JSON.stringify(value);\n      }\n\n      if (obj.hasOwnProperty(key) && typeof value !== 'function') {\n        localStorage.setItem(key, value);\n      }\n    }\n  },\n\n  get: (key: string) => {\n    try {\n      let result: any = localStorage.getItem(key);\n      if (result && result[0] === \"{\") {\n        result = JSON.parse(result);\n      }\n      return result;\n    } catch(e) {\n      console.warn('not found value');\n      console.error(e);\n    }\n  },\n\n  del: (key: string) => {\n    try {\n      localStorage.removeItem(key);\n    } catch(e) {\n      console.warn('can not remove item');\n      console.error(e);\n    }\n  },\n\n  append: (key: string, target?: any) => {\n    let source: object = storage.get(key);\n\n    if (source === null) {\n      source = {};\n    }\n\n    return storage.set({ [key]: Object.assign(target, source) });\n  }\n};\n\nexport default storage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/storage.ts","interface Utils {\n  foo: string;\n  bar: number;\n}\n\nclass SomeUtils implements Utils {\n  private options: any;\n  private params: any;\n  foo: string;\n  bar: number;\n\n  constructor(options: any = {}) {\n    this.foo = options;\n    this.params = options.params || {};\n  }\n\n  init(options?: any): { options: any } {\n    console.log(this.foo);\n    return options;\n  }\n\n  mainFunction(params: object = {}): any {\n    // console.log(params)\n    console.log('mainFunction');\n    return params;\n  }\n\n  someFunction(): void {\n    console.log('someFunction');\n  }\n}\n\n// 内部API\nclass otherUtils {\n  static Foo = {};\n  static Bar = 0;\n\n  foo: object;\n  bar: number;\n\n  constructor(params: Utils) {\n    this.foo = params.foo || otherUtils.Foo;\n    this.bar = params.bar || otherUtils.Bar;\n    console.log('Print otherUtils class constructor function: ');\n    console.log(params);\n  }\n\n  init(options?: any): { options: any } {\n    console.log('Print otherUtils class init function: ');\n    console.log(`foo object: ${this.foo}`);\n    console.log(`bar object: ${this.bar}`);\n    return options;\n  }\n}\n\nvar o = new otherUtils({ foo: 'foo value', bar: 1 });\no.init();\n\nconst utils = SomeUtils;\n\nexport = utils;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.ts","if (typeof Object.assign !== 'function') {\n  (function() {\n    Object.assign = function(target?: any, ...args: any[]) {\n\n      if (!target) {\n        throw TypeError('Cannot convert undefined or null to object');\n      }\n      for (const source of args) {\n        if (source) {\n          Object.keys(source).forEach(key => target[key] = source[key]);\n        }\n      }\n      return target;\n    };\n  })();\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/polyfill/object-assign.ts","/**\n * Helper class for capturing stack traces.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n// TODO:\n// - test/make it work in non-V8\n// - parse stacks into platform-independent object-arrays\nvar hasStacks = (typeof Error.captureStackTrace === \"function\");\nvar Stack = (function () {\n    function Stack(ignoreUntil) {\n        if (ignoreUntil === void 0) { ignoreUntil = Stack; }\n        /* istanbul ignore else */ // TODO: remove when testing for non-V8\n        if (hasStacks) {\n            Error.captureStackTrace(this, ignoreUntil);\n        }\n        else {\n            this.stack = \"dummy\\n<no trace>\";\n        }\n    }\n    Stack.prototype.inspect = function () {\n        var lines = this.stack.split(\"\\n\");\n        lines.shift(); // Strip the \"[object Object]\" line\n        return lines.join(\"\\n\");\n    };\n    return Stack;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Stack;\n//# sourceMappingURL=Stack.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/Stack.js\n// module id = 17\n// module chunks = 0","/**\n * Helper class for capturing stack traces.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n// TODO:\n// - test/make it work in non-V8\nvar Stack_1 = require(\"./Stack\");\n/**\n * Stack trace container with optional source traces.\n *\n * Typically used for capturing traces across asynchronous calls (e.g.\n * with Promises or Events).\n */\nvar Trace = (function () {\n    function Trace(ignoreUntil) {\n        if (ignoreUntil === void 0) { ignoreUntil = Trace; }\n        this.stack = new Stack_1.default(ignoreUntil);\n    }\n    /**\n     * Assign another Trace as the source of this Trace.\n     *\n     * Note: the stack of `source` is copied to this Trace, in order to allow\n     * truncating the trace length to `Trace.traceLimit` to prevent memory\n     * exhaustion on e.g. recursive traces.\n     *\n     * @param source Trace to use as source.\n     */\n    Trace.prototype.setSource = function (source) {\n        if (!source.sources) {\n            this.sources = [source.stack];\n        }\n        else {\n            this.sources = source.sources.concat(source.stack);\n            if (this.sources.length > Trace.traceLimit) {\n                this.sources = this.sources.slice(0, Trace.traceLimit);\n            }\n        }\n    };\n    Trace.prototype.inspect = function () {\n        var result = this.stack.inspect();\n        if (this.sources) {\n            for (var i = this.sources.length - 1; i >= 0; i--) {\n                result += \"\\n  from previous:\\n\" + this.sources[i].inspect();\n            }\n        }\n        return result;\n    };\n    Trace.traceLimit = 10;\n    return Trace;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Trace;\n//# sourceMappingURL=Trace.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/Trace.js\n// module id = 18\n// module chunks = 0","/**\n * Call queue for executing callbacks asynchronously.\n *\n * Prevents releasing Zalgo.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\n// TODO:\n// - simpler code\nvar util_1 = require(\"./util\");\nvar CallQueue = (function () {\n    function CallQueue() {\n        this.length = 0;\n        // Basically twice the number of simultaneously resolving promises\n        this._max = 1000;\n        this._first = 0;\n    }\n    /**\n     * Push a new callback to the queue.\n     * @return true when the queue still has space, false if it's now 'full'\n     */\n    CallQueue.prototype.push = function (callback, arg) {\n        this[this.length++] = callback;\n        this[this.length++] = arg;\n        return this.length < this._max;\n    };\n    /**\n     * Flush all callbacks in this queue.\n     * Note that it is 'ok' for callbacks to throw an error;\n     * the next call to flush() will flush the remainder of the queue.\n     * When this function returns, the queue will be 'reset' to its beginning.\n     */\n    CallQueue.prototype.flush = function () {\n        while (this._first < this.length) {\n            var callback = this[this._first];\n            var arg = this[this._first + 1];\n            this[this._first] = this[this._first + 1] = undefined;\n            this._first += 2;\n            callback(arg);\n        }\n        this.length = 0;\n        this._first = 0;\n    };\n    return CallQueue;\n}());\nvar Async = (function () {\n    function Async() {\n        var _this = this;\n        /* tslint:disable:member-ordering */ // trips on the arrow-function, thinks it's something public\n        this._pool = [];\n        this._ring = [new CallQueue()];\n        this._current = this._ring[0];\n        this._flusher = function () { return _this._scheduledFlush(); };\n        this._flushing = false;\n        this._scheduled = false;\n        this._scheduler = undefined;\n    }\n    /* tslint:enable:member-ordering */\n    /**\n     * Configure alternative scheduler to use.\n     * The scheduler function will be called with a flusher, which needs to be\n     * executed to flush the queue. Note: the flusher may throw an\n     * exception, if any of the callbacks on the queue throws one.\n     * This will result in another flush to be scheduled before returning.\n     *\n     * Call with `undefined` to reset the scheduler to the default (setImmediate).\n     *\n     * Example usage (this is basically the default):\n     *   setScheduler((flusher) => setImmediate(flusher));\n     */\n    Async.prototype.setScheduler = function (scheduler) {\n        /* tslint:disable:no-null-keyword */ // 'old' API told you to use `null` instead of `undefined`\n        util_1.assert(scheduler === undefined || scheduler === null || typeof scheduler === \"function\");\n        /* tslint:enable:no-null-keyword */\n        this._scheduler = scheduler;\n    };\n    Async.prototype.enqueue = function (callback, arg) {\n        if (!this._flushing && !this._scheduled) {\n            this._schedule();\n        }\n        if (!this._current) {\n            this._current = this._pool.pop();\n            if (!this._current) {\n                this._current = new CallQueue();\n            }\n            this._ring.push(this._current);\n        }\n        if (!this._current.push(callback, arg)) {\n            this._current = undefined;\n        }\n    };\n    Async.prototype.flush = function () {\n        util_1.assert(!this._flushing, \"cannot recursively flush\");\n        this._flushing = true;\n        try {\n            while (true) {\n                // Note: ring is guaranteed to have at least one queue (even though\n                // queue might be empty when flush() is e.g. called manually).\n                this._ring[0].flush();\n                // ring[0] is now guaranteed to be empty, so we could move it to\n                // the pool.\n                // However, if it's the last item remaining, better to simply\n                // leave it in the ring, saves unnecessary re-move on next\n                // enqueue.\n                if (this._ring.length === 1) {\n                    // First queue is now empty, so we can re-use it again (if\n                    // it was full last time)\n                    this._current = this._ring[0];\n                    break;\n                }\n                util_1.assert(this._current !== this._ring[0]);\n                this._pool.push(this._ring.shift());\n            }\n        }\n        finally {\n            this._flushing = false;\n            // If one of the callbacks in the queue throws an exception,\n            // (e.g. when Promise#done() detects a rejection) make sure to\n            // reschedule the remainder of the queue(s) for another iteration.\n            // This approach has the advantage of immediately allowing to stop\n            // the program in e.g. NodeJS, but also allows to continue running\n            // correctly in a browser.\n            if (this._ring[0].length > 0 && !this._scheduled) {\n                this._schedule();\n            }\n        }\n    };\n    Async.prototype._schedule = function () {\n        util_1.assert(!this._scheduled);\n        // Note: we 'fall back' to setImmediate here (instead of e.g.\n        // assigning it to the _scheduler property once), to allow\n        // setImmediate to be e.g. replaced by a mocked one (e.g. Sinon's\n        // useFakeTimers())\n        var scheduler = this._scheduler;\n        if (!scheduler) {\n            scheduler = typeof setImmediate === \"function\" ? setImmediate : setTimeout;\n        }\n        scheduler(this._flusher);\n        this._scheduled = true;\n    };\n    Async.prototype._scheduledFlush = function () {\n        // Indicate that this 'iteration' of the flush is complete.\n        this._scheduled = false;\n        this.flush();\n    };\n    return Async;\n}());\nexports.Async = Async;\nexports.async = new Async();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports.async;\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/async.js\n// module id = 19\n// module chunks = 0","/**\n * TS-Promise - fast, robust, type-safe promises\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar Promise_1 = require(\"./Promise\");\nexports.default = Promise_1.default;\nexports.Promise = Promise_1.Promise;\nexports.UnhandledRejectionError = Promise_1.UnhandledRejectionError;\nvar polyfill_1 = require(\"./polyfill\");\nexports.polyfill = polyfill_1.default;\n// Temporary, should be moved to its own package some day\nvar BaseError_1 = require(\"./BaseError\");\nexports.BaseError = BaseError_1.default;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/index.js\n// module id = 20\n// module chunks = 0","/**\n * Polyfill implementation.\n *\n * Copyright (C) 2016 Martin Poelstra\n * License: MIT\n */\n\"use strict\";\nvar Promise_1 = require(\"./Promise\");\nvar util_1 = require(\"./util\");\n/**\n * Polyfill global `Promise` instance with ts-promise version.\n * By default, it will only install a ts-promise version if no other\n * implementation is present. Use `force = true` to unconditionally replace the\n * promise implementation.\n *\n * Warning: in general, it's not really recommended to use polyfills, because\n * other libraries may e.g. use the fact that certain platform features are\n * absent to create a 'fingerprint' of a platform, and it may conflict with\n * other libraries that are trying to do the same thing.\n * If you're writing your own library, it's much better to simply directly\n * require/import ts-promise, and use its class directly.\n * However, if you're the 'end-user' (i.e. application, not a library), it may\n * be a viable solution to make Promises available on platforms that otherwise\n * don't have them.\n *\n * @param  {boolean}  force (Optional, default false) Forcibly overwrite existing Promise implementation with ts-promise version.\n * @return {boolean}        Returns true when global Promise is (now) a ts-promise (or derived class), false otherwise.\n */\nfunction polyfill(force) {\n    if (force === void 0) { force = false; }\n    // Get reference to globals (`global`, `window`, etc.)\n    var global = util_1.getGlobal();\n    if (!global) {\n        return false;\n    }\n    if (force || typeof global.Promise !== \"function\") {\n        global.Promise = Promise_1.Promise;\n        return true;\n    }\n    return global.Promise instanceof Promise_1.Promise;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = polyfill;\n//# sourceMappingURL=polyfill.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ts-promise/dist/lib/polyfill.js\n// module id = 21\n// module chunks = 0"],"sourceRoot":""}